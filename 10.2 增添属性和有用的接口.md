# 10.2 增添屬性和有用的接口


利用層次化對象動態和透明地添加單個對象的能力的做法叫作“裝飾器”（Decorator）方案——“方案”屬於本書第16章的主題（註釋①）。裝飾器方案規定封裝於初始化對象中的所有對象都擁有相同的接口，以便利用裝飾器的“透明”性質——我們將相同的消息發給一個對象，無論它是否已被“裝飾”。這正是在Java IO庫裡存在“過濾器”（Filter）類的原因：抽象的“過濾器”類是所有裝飾器的基類（裝飾器必須擁有與它裝飾的那個對象相同的接口，但裝飾器亦可對接口作出擴展，這種情況見諸於幾個特殊的“過濾器”類中）。

子類處理要求大量子類對每種可能的組合提供支持時，便經常會用到裝飾器——由於組合形式太多，造成子類處理變得不切實際。Java IO庫要求許多不同的特性組合方案，這正是裝飾器方案顯得特別有用的原因。但是，裝飾器方案也有自己的一個缺點。在我們寫一個程序的時候，裝飾器為我們提供了大得多的靈活性（因為可以方便地混合與匹配屬性），但它們也使自己的代碼變得更加複雜。原因在於Java IO庫操作不便，我們必須創建許多類——“核心”IO類型加上所有裝飾器——才能得到自己希望的單個IO對象。

`FilterInputStream`和`FilterOutputStream`（這兩個名字不十分直觀）提供了相應的裝飾器接口，用於控制一個特定的輸入流（`InputStream`）或者輸出流（`OutputStream`）。它們分別是從`InputStream`和`OutputStream`派生出來的。此外，它們都屬於抽象類，在理論上為我們與一個流的不同通信手段都提供了一個通用的接口。事實上，`FilterInputStream`和`FilterOutputStream`只是簡單地模仿了自己的基類，它們是一個裝飾器的基本要求。

## 10.2.1 通過`FilterInputStream`從`InputStream`裡讀入數據

`FilterInputStream`類要完成兩件全然不同的事情。其中，`DataInputStream`允許我們讀取不同的基本類型數據以及`String`對象（所有方法都以`read`開頭，比如`readByte()`，`readFloat()`等等）。伴隨對應的`DataOutputStream`，我們可通過數據“流”將基本類型的數據從一個地方搬到另一個地方。這些“地方”是由表10.1總結的那些類決定的。若讀取塊內的數據，並自己進行解析，就不需要用到`DataInputStream`。但在其他許多情況下，我們一般都想用它對自己讀入的數據進行自動格式化。

剩下的類用於修改`InputStream`的內部行為方式：是否進行緩衝，是否跟蹤自己讀入的數據行，以及是否能夠推回一個字符等等。後兩種類看起來特別象提供對構建一個編譯器的支持（換言之，添加它們為了支持Java編譯器的構建），所以在常規編程中一般都用不著它們。

也許幾乎每次都要緩衝自己的輸入，無論連接的是哪個IO設備。所以IO庫最明智的做法就是將未緩衝輸入作為一種特殊情況處理，同時將緩衝輸入接納為標準做法。

表10.3 `FilterInputStream`的類型

```
Class

Function

Constructor Arguments

How to use it

Data-InputStream

Used in concert with DataOutputStream, so you can read primitives (int, char, long, etc.) from a stream in a portable fashion.

InputStream

Contains a full interface to allow you to read primitive types.


Buffered-InputStream

Use this to prevent a physical read every time you want more data. You’re saying “Use a buffer.”

InputStream, with optional buffer size.

This doesn’t provide an interface per se, just a requirement that a buffer be used. Attach an interface object.

LineNumber-InputStream

Keeps track of line numbers in the input stream; you can call getLineNumber( ) and setLineNumber(int).

InputStream

This just adds line numbering, so you’ll probably attach an interface object.

Pushback-InputStream

Has a one byte push-back buffer so that you can push back the last character read.

InputStream

Generally used in the scanner for a compiler and probably included because the Java compiler needed it. You probably won’t use this.
```

| 類 | 功能 | 構造器參數／如何使用
| --- | --- | --- |
| `DataInputStream` | 與`DataOutputStream`聯合使用，使自己能以機動方式讀取一個流中的基本數據類型（`int`，`char`，`long`等等） | `InputStream`/包含了一個完整的接口，以便讀取基本數據類型 |
| `BufferedInputStream` | 避免每次想要更多數據時都進行物理性的讀取，告訴它“請先在緩衝區裡找” | `InputStream`，沒有可選的緩衝區大小／本身並不能提供一個接口，只是發出使用緩衝區的要求。要求同一個接口對象連接到一起 |
| `LineNumberInputStream` | 跟蹤輸入流中的行號；可調用`getLineNumber()`以及`setLineNumber(int) `| 只是添加對數據行編號的能力，所以可能需要同一個真正的接口對象連接 |
| `PushbackInputStream` | 有一個字節的後推緩衝區，以便後推讀入的上一個字符 | `InputStream`／通常由編譯器在掃描器中使用，因為Java編譯器需要它。一般不在自己的代碼中使用 |

## 10.2.2 通過`FilterOutputStream向OutputStream`裡寫入數據

與`DataInputStream`對應的是`DataOutputStream`，後者對各個基本數據類型以及`String`對象進行格式化，並將其置入一個數據“流”中，以便任何機器上的`DataInputStream`都能正常地讀取它們。所有方法都以`wirte`開頭，例如`writeByte()`，`writeFloat()`等等。

若想進行一些真正的格式化輸出，比如輸出到控制檯，請使用`PrintStrea`m。利用它可以打印出所有基本數據類型以及`String`對象，並可採用一種易於查看的格式。這與`DataOutputStream`正好相反，後者的目標是將那些數據置入一個數據流中，以便`DataInputStream`能夠方便地重新構造它們。`System.out`靜態對象是一個`PrintStream`。

`PrintStream`內兩個重要的方法是`print()`和`println()`。它們已進行了覆蓋處理，可打印出所有數據類型。`print()`和`println()`之間的差異是後者在操作完畢後會自動添加一個新行。

`BufferedOutputStream`屬於一種“修改器”，用於指示數據流使用緩衝技術，使自己不必每次都向流內物理性地寫入數據。通常都應將它應用於文件處理和控制器IO。

表10.4 `FilterOutputStream`的類型

```
Class

Function

Constructor Arguments

How to use it

Data-OutputStream

Used in concert with DataInputStream so you can write primitives (int, char, long, etc.) to a stream in a portable fashion.

OutputStream

Contains full interface to allow you to write primitive types.

PrintStream

For producing formatted output. While DataOutputStream handles the storage of data, PrintStream handles display.

OutputStream, with optional boolean indicating that the buffer is flushed with every newline.

Should be the “final” wrapping for your OutputStream object. You’ll probably use this a lot.

Buffered-OutputStream

Use this to prevent a physical write every time you send a piece of data. You’re saying “Use a buffer.” You can call flush( ) to flush the buffer.

OutputStream, with optional buffer size.

This doesn’t provide an interface per se, just a requirement that a buffer is used. Attach an interface object.
```

| 類 | 功能 | 構造器參數／如何使用 |
| --- | --- | --- |
| `DataOutputStream` | 與`DataInputStream`配合使用，以便採用方便的形式將基本數據類型（`int`，`char`，`long`等）寫入一個數據流 | `OutputStream`／包含了完整接口，以便我們寫入基本數據類型 |
| `PrintStream` | 用於產生格式化輸出。 | `DataOutputStream`控制的是數據的“存儲”，而`PrintStream`控制的是“顯示” |
| `OutputStream` |  | 可選一個布爾參數，指示緩衝區是否與每個新行一同刷新／對於自己的OutputStream對象，應該用`final`將其封閉在內。可能經常都要用到它 |
| `BufferedOutputStream` | 用它避免每次發出數據的時候都要進行物理性的寫入，要求它“請先在緩衝區裡找”。可調用`flush()`，對緩衝區進行刷新 | `OutputStream`，可選緩衝區大小／本身並不能提供一個接口，只是發出使用緩衝區的要求。需要同一個接口對象連接到一起 |
