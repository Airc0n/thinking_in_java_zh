# 15.1 機器的標識

當然，為了分辨來自別處的一臺機器，以及為了保證自己連接的是希望的那臺機器，必須有一種機制能獨一無二地標識出網絡內的每臺機器。早期網絡只解決了如何在本地網絡環境中為機器提供唯一的名字。但Java面向的是整個因特網，這要求用一種機制對來自世界各地的機器進行標識。為達到這個目的，我們採用了IP（互聯網地址）的概念。IP以兩種形式存在著：

(1) 大家最熟悉的DNS（域名服務）形式。我自己的域名是`bruceeckel.com`。所以假定我在自己的域內有一臺名為Opus的計算機，它的域名就可以是`Opus.bruceeckel.com`。這正是大家向其他人發送電子函件時採用的名字，而且通常集成到一個萬維網（WWW）地址裡。

(2) 此外，亦可採用“四點”格式，亦即由點號（.）分隔的四組數字，比如`202.98.32.111`。
不管哪種情況，IP地址在內部都表達成一個由32個二進制位（bit）構成的數字（註釋①），所以IP地址的每一組數字都不能超過255。利用由`java.net`提供的`static InetAddress.getByName()`，我們可以讓一個特定的Java對象表達上述任何一種形式的數字。結果是類型為`InetAddress`的一個對象，可用它構成一個“套接字”（`Socket`），大家在後面會見到這一點。

①：這意味著最多隻能得到40億左右的數字組合，全世界的人很快就會把它用光。但根據目前正在研究的新IP編址方案，它將採用128 bit的數字，這樣得到的唯一性IP地址也許在幾百年的時間裡都不會用完。

作為運用`InetAddress.getByName()`一個簡單的例子，請考慮假設自己有一家撥號連接因特網服務提供者（ISP），那麼會發生什麼情況。每次撥號連接的時候，都會分配得到一個臨時IP地址。但在連接期間，那個IP地址擁有與因特網上其他IP地址一樣的有效性。如果有人按照你的IP地址連接你的機器，他們就有可能使用在你機器上運行的Web或者FTP服務器程序。當然這有個前提，對方必須準確地知道你目前分配到的IP。由於每次撥號連接獲得的IP都是隨機的，怎樣才能準確地掌握你的IP呢？

下面這個程序利用`InetAddress.getByName()`來產生你的IP地址。為了讓它運行起來，事先必須知道計算機的名字。該程序只在Windows 95中進行了測試，但大家可以依次進入自己的“開始”、“設置”、“控制面板”、“網絡”，然後進入“標識”卡片。其中，“計算機名稱”就是應在命令行輸入的內容。

```
//: WhoAmI.java
// Finds out your network address when you're
// connected to the Internet.
package c15;
import java.net.*;

public class WhoAmI {
  public static void main(String[] args)
      throws Exception {
    if(args.length != 1) {
      System.err.println(
        "Usage: WhoAmI MachineName");
      System.exit(1);
    }
    InetAddress a =
      InetAddress.getByName(args[0]);
    System.out.println(a);
  }
} ///:~
```

就我自己的情況來說，機器的名字叫作`Colossus`（來自同名電影，“巨人”的意思。我在這臺機器上有一個很大的硬盤）。所以一旦連通我的ISP，就象下面這樣執行程序：

```
java whoAmI Colossus
```

得到的結果象下面這個樣子（當然，這個地址可能每次都是不同的）：

```
Colossus/202.98.41.151
```

假如我把這個地址告訴一位朋友，他就可以立即登錄到我的個人Web服務器，只需指定目標地址 `http://202.98.41.151` 即可（當然，我此時不能斷線）。有些時候，這是向其他人發送信息或者在自己的Web站點正式出臺以前進行測試的一種方便手段。

## 15.1.1 服務器和客戶端

網絡最基本的精神就是讓兩臺機器連接到一起，並相互“交談”或者“溝通”。一旦兩臺機器都發現了對方，就可以展開一次令人愉快的雙向對話。但它們怎樣才能“發現”對方呢？這就象在遊樂園裡那樣：一臺機器不得不停留在一個地方，監聽其他機器說：“嘿，你在哪裡呢？”

“停留在一個地方”的機器叫作“服務器”（Server）；到處“找人”的機器則叫作“客戶端”（Client）或者“客戶”。它們之間的區別只有在客戶端試圖同服務器連接的時候才顯得非常明顯。一旦連通，就變成了一種雙向通信，誰來扮演服務器或者客戶端便顯得不那麼重要了。

所以服務器的主要任務是監聽建立連接的請求，這是由我們創建的特定服務器對象完成的。而客戶端的任務是試著與一臺服務器建立連接，這是由我們創建的特定客戶端對象完成的。一旦連接建好，那麼無論在服務器端還是客戶端端，連接只是魔術般地變成了一個IO數據流對象。從這時開始，我們可以象讀寫一個普通的文件那樣對待連接。所以一旦建好連接，我們只需象第10章那樣使用自己熟悉的IO命令即可。這正是Java連網最方便的一個地方。

(1) 在沒有網絡的前提下測試程序

由於多種潛在的原因，我們可能沒有一臺客戶端、服務器以及一個網絡來測試自己做好的程序。我們也許是在一個課堂環境中進行練習，或者寫出的是一個不十分可靠的網絡應用，還能拿到網絡上去。IP的設計者注意到了這個問題，並建立了一個特殊的地址——`localhost`——來滿足非網絡環境中的測試要求。在Java中產生這個地址最一般的做法是：

```
InetAddress addr = InetAddress.getByName(null);
```

如果向`getByName()`傳遞一個`null`（空）值，就默認為使用`localhost`。我們`用InetAddress`對特定的機器進行索引，而且必須在進行進一步的操作之前得到這個`InetAddress`（互聯網地址）。我們不可以操縱一個`InetAddress`的內容（但可把它打印出來，就象下一個例子要演示的那樣）。創建`InetAddress`的唯一途徑就是那個類的static（靜態）成員方法`getByName()`（這是最常用的）、`getAllByName()`或者`getLocalHost()`。

為得到本地主機地址，亦可向其直接傳遞字符串`"localhost"`：

```
InetAddress.getByName("localhost");
```

或者使用它的保留IP地址（四點形式），就象下面這樣：

```
InetAddress.getByName("127.0.0.1");
```

這三種方法得到的結果是一樣的。

## 15.1.2 端口：機器內獨一無二的場所

有些時候，一個IP地址並不足以完整標識一個服務器。這是由於在一臺物理性的機器中，往往運行著多個服務器（程序）。由IP表達的每臺機器也包含了“端口”（Port）。我們設置一個客戶端或者服務器的時候，必須選擇一個無論客戶端還是服務器都認可連接的端口。就象我們去拜會某人時，IP地址是他居住的房子，而端口是他在的那個房間。

注意端口並不是機器上一個物理上存在的場所，而是一種軟件抽象（主要是為了表述的方便）。客戶程序知道如何通過機器的IP地址同它連接，但怎樣才能同自己真正需要的那種服務連接呢（一般每個端口都運行著一種服務，一臺機器可能提供了多種服務，比如HTTP和FTP等等）？端口編號在這裡扮演了重要的角色，它是必需的一種二級定址措施。也就是說，我們請求一個特定的端口，便相當於請求與那個端口編號關聯的服務。“報時”便是服務的一個典型例子。通常，每個服務都同一臺特定服務器機器上的一個獨一
無二的端口編號關聯在一起。客戶程序必須事先知道自己要求的那項服務的運行端口號。

系統服務保留了使用端口1到端口1024的權力，所以不應讓自己設計的服務佔用這些以及其他任何已知正在使用的端口。本書的第一個例子將使用端口8080（為追憶我的第一臺機器使用的老式8位Intel 8080芯片，那是一部使用CP/M操作系統的機子）。
