# 10.5 IO流的典型應用

儘管庫內存在大量IO流類，可通過多種不同的方式組合到一起，但實際上只有幾種方式才會經常用到。然而，必須小心在意才能得到正確的組合。下面這個相當長的例子展示了典型IO配置的創建與使用，可在寫自己的代碼時將其作為一個參考使用。注意每個配置都以一個註釋形式的編號起頭，並提供了適當的解釋信息。

```
//: IOStreamDemo.java
// Typical IO Stream Configurations
import java.io.*;
import com.bruceeckel.tools.*;

public class IOStreamDemo {
  public static void main(String[] args) {
    try {
      // 1. Buffered input file
      DataInputStream in =
        new DataInputStream(
          new BufferedInputStream(
            new FileInputStream(args[0])));
      String s, s2 = new String();
      while((s = in.readLine())!= null)
        s2 += s + "\n";
      in.close();

      // 2. Input from memory
      StringBufferInputStream in2 =
          new StringBufferInputStream(s2);
      int c;
      while((c = in2.read()) != -1)
        System.out.print((char)c);

      // 3. Formatted memory input
      try {
        DataInputStream in3 =
          new DataInputStream(
            new StringBufferInputStream(s2));
        while(true)
          System.out.print((char)in3.readByte());
      } catch(EOFException e) {
        System.out.println(
          "End of stream encountered");
      }

      // 4. Line numbering & file output
      try {
        LineNumberInputStream li =
          new LineNumberInputStream(
            new StringBufferInputStream(s2));
        DataInputStream in4 =
          new DataInputStream(li);
        PrintStream out1 =
          new PrintStream(
            new BufferedOutputStream(
              new FileOutputStream(
                "IODemo.out")));
        while((s = in4.readLine()) != null )
          out1.println(
            "Line " + li.getLineNumber() + s);
        out1.close(); // finalize() not reliable!
      } catch(EOFException e) {
        System.out.println(
          "End of stream encountered");
      }

      // 5. Storing & recovering data
      try {
        DataOutputStream out2 =
          new DataOutputStream(
            new BufferedOutputStream(
              new FileOutputStream("Data.txt")));
        out2.writeBytes(
          "Here's the value of pi: \n");
        out2.writeDouble(3.14159);
        out2.close();
        DataInputStream in5 =
          new DataInputStream(
            new BufferedInputStream(
              new FileInputStream("Data.txt")));
        System.out.println(in5.readLine());
        System.out.println(in5.readDouble());
      } catch(EOFException e) {
        System.out.println(
          "End of stream encountered");
      }

      // 6. Reading/writing random access files
      RandomAccessFile rf =
        new RandomAccessFile("rtest.dat", "rw");
      for(int i = 0; i < 10; i++)
        rf.writeDouble(i*1.414);
      rf.close();

      rf =
        new RandomAccessFile("rtest.dat", "rw");
      rf.seek(5*8);
      rf.writeDouble(47.0001);
      rf.close();

      rf =
        new RandomAccessFile("rtest.dat", "r");
      for(int i = 0; i < 10; i++)
        System.out.println(
          "Value " + i + ": " +
          rf.readDouble());
      rf.close();

      // 7. File input shorthand
      InFile in6 = new InFile(args[0]);
      String s3 = new String();
      System.out.println(
        "First line in file: " +
        in6.readLine());
        in6.close();

      // 8. Formatted file output shorthand
      PrintFile out3 = new PrintFile("Data2.txt");
      out3.print("Test of PrintFile");
      out3.close();

      // 9. Data file output shorthand
      OutFile out4 = new OutFile("Data3.txt");
      out4.writeBytes("Test of outDataFile\n\r");
      out4.writeChars("Test of outDataFile\n\r");
      out4.close();

    } catch(FileNotFoundException e) {
      System.out.println(
        "File Not Found:" + args[0]);
    } catch(IOException e) {
      System.out.println("IO Exception");
    }
  }
} ///:~
```

## 10.5.1 輸入流

當然，我們經常想做的一件事情是將格式化的輸出打印到控制檯，但那已在第5章創建的`com.bruceeckel.tools`中得到了簡化。

第1到第4部分演示了輸入流的創建與使用（儘管第4部分展示了將輸出流作為一個測試工具的簡單應用）。

(1) 緩衝的輸入文件

為打開一個文件以便輸入，需要使用一個`FileInputStream`，同時將一個`String`或`File`對象作為文件名使用。為提高速度，最好先對文件進行緩衝處理，從而獲得用於一個`BufferedInputStream`的構造器的結果引用。為了以格式化的形式讀取輸入數據，我們將那個結果引用賦給用於一個`DataInputStream`的構造器。`DataInputStream`是我們的最終（`final`）對象，並是我們進行讀取操作的接口。

在這個例子中，只用到了`readLine()`方法，但理所當然任何`DataInputStream`方法都可以採用。一旦抵達文件末尾，`readLine()`就會返回一個`null`（空），以便中止並退出`while`循環。

`String s2`用於聚集完整的文件內容（包括必須添加的新行，因為`readLine()`去除了那些行）。隨後，在本程序的後面部分中使用`s2`。最後，我們調用`close()`，用它關閉文件。從技術上說，會在運行`finalize()`時調用`close()`。而且我們希望一旦程序退出，就發生這種情況（無論是否進行垃圾收集）。然而，Java 1.0有一個非常突出的錯誤（Bug），造成這種情況不會發生。在Java 1.1中，必須明確調用`System.runFinalizersOnExit(true)`，用它保證會為系統中的每個對象調用`finalize()`。然而，最安全的方法還是為文件明確調用`close()`。

(2) 從內存輸入

這一部分採用已經包含了完整文件內容的`String s2`，並用它創建一個`StringBufferInputStream`（字符串緩衝輸入流）——作為構造器的參數，要求使用一個`String`，而非一個`StringBuffer`）。隨後，我們用`read()`依次讀取每個字符，並將其發送至控制檯。注意`read()`將下一個字節返回為`int`，所以必須將其轉換為一個`char`，以便正確地打印。

(3) 格式化內存輸入

`StringBufferInputStream`的接口是有限的，所以通常需要將其封裝到一個`DataInputStream`內，從而增強它的能力。然而，若選擇用`readByte()`每次讀出一個字符，那麼所有值都是有效的，所以不可再用返回值來偵測何時結束輸入。相反，可用`available()`方法判斷有多少字符可用。下面這個例子展示瞭如何從文件中一次讀出一個字符：

```
//: TestEOF.java
// Testing for the end of file while reading
// a byte at a time.
import java.io.*;

public class TestEOF {
  public static void main(String[] args) {
    try {
      DataInputStream in =
        new DataInputStream(
         new BufferedInputStream(
          new FileInputStream("TestEof.java")));
      while(in.available() != 0)
        System.out.print((char)in.readByte());
    } catch (IOException e) {
      System.err.println("IOException");
    }
  }
} ///:~
```

注意取決於當前從什麼媒體讀入，`avaiable()`的工作方式也是有所區別的。它在字面上意味著“可以不受阻塞讀取的字節數量”。對一個文件來說，它意味著整個文件。但對一個不同種類的數據流來說，它卻可能有不同的含義。因此在使用時應考慮周全。

為了在這樣的情況下偵測輸入的結束，也可以通過捕獲一個異常來實現。然而，若真的用異常來控制數據流，卻顯得有些大材小用。

(4) 行的編號與文件輸出

這個例子展示瞭如何`LineNumberInputStream`來跟蹤輸入行的編號。在這裡，不可簡單地將所有構造器都組合起來，因為必須保持`LineNumberInputStream`的一個引用（注意這並非一種繼承環境，所以不能簡單地將`in4`轉換到一個`LineNumberInputStream`）。因此，`li`容納了指向`LineNumberInputStream`的引用，然後在它的基礎上創建一個`DataInputStream`，以便讀入數據。

這個例子也展示瞭如何將格式化數據寫入一個文件。首先創建了一個`FileOutputStream`，用它同一個文件連接。考慮到效率方面的原因，它生成了一個`BufferedOutputStream`。這幾乎肯定是我們一般的做法，但卻必須明確地這樣做。隨後為了進行格式化，它轉換成一個`PrintStream`。用這種方式創建的數據文件可作為一個原始的文本文件讀取。

標誌`DataInputStream`何時結束的一個方法是`readLine()`。一旦沒有更多的字符串可以讀取，它就會返回`null`。每個行都會伴隨自己的行號打印到文件裡。該行號可通過`li`查詢。

可看到用於`out1`的、一個明確指定的`close()`。若程序準備掉轉頭來，並再次讀取相同的文件，這種做法就顯得相當有用。然而，該程序直到結束也沒有檢查文件`IODemo.txt`。正如以前指出的那樣，如果不為自己的所有輸出文件調用`close()`，就可能發現緩衝區不會得到刷新，造成它們不完整。。

## 10.5.2 輸出流

兩類主要的輸出流是按它們寫入數據的方式劃分的：一種按人的習慣寫入，另一種為了以後由一個`DataInputStream`而寫入。`RandomAccessFile`是獨立的，儘管它的數據格式兼容於`DataInputStream`和`DataOutputStream`。

(5) 保存與恢復數據

`PrintStream`能格式化數據，使其能按我們的習慣閱讀。但為了輸出數據，以便由另一個數據流恢復，則需用一個`DataOutputStream`寫入數據，並用一個`DataInputStream`恢復（獲取）數據。當然，這些數據流可以是任何東西，但這裡採用的是一個文件，並進行了緩衝處理，以加快讀寫速度。

注意字符串是用`writeBytes()`寫入的，而非`writeChars()`。若使用後者，寫入的就是16位Unicode字符。由於`DataInputStream`中沒有補充的`readChars`方法，所以不得不用`readChar()`每次取出一個字符。所以對ASCII來說，更方便的做法是將字符作為字節寫入，在後面跟隨一個新行；然後再用`readLine()`將字符當作普通的ASCII行讀回。

`writeDouble()`將`double`數字保存到數據流中，並用補充的`readDouble()`恢復它。但為了保證任何讀方法能夠正常工作，必須知道數據項在流中的準確位置，因為既有可能將保存的`double`數據作為一個簡單的字節序列讀入，也有可能作為`char`或其他格式讀入。所以必須要麼為文件中的數據採用固定的格式，要麼將額外的信息保存到文件中，以便正確判斷數據的存放位置。

(6) 讀寫隨機訪問文件

正如早先指出的那樣，`RandomAccessFile`與IO層次結構的剩餘部分幾乎是完全隔離的，儘管它也實現了DataInput和`DataOutput`接口。所以不可將其與`InputStream`及`OutputStream`子類的任何部分關聯起來。儘管也許能將一個`ByteArrayInputStream`當作一個隨機訪問元素對待，但只能用`RandomAccessFile`打開一個文件。必須假定`RandomAccessFile`已得到了正確的緩衝，因為我們不能自行選擇。

可以自行選擇的是第二個構造器參數：可決定以“只讀”（`r`）方式或“讀寫”（`rw`）方式打開一個`RandomAccessFile`文件。

使用`RandomAccessFile`的時候，類似於組合使用`DataInputStream`和`DataOutputStream`（因為它實現了等同的接口）。除此以外，還可看到程序中使用了`seek()`，以便在文件中到處移動，對某個值作出修改。

## 10.5.3 快捷文件處理

由於以前採用的一些典型形式都涉及到文件處理，所以大家也許會懷疑為什麼要進行那麼多的代碼輸入——這正是裝飾器方案一個缺點。本部分將向大家展示如何創建和使用典型文件讀取和寫入配置的快捷版本。這些快捷版本均置入`packagecom.bruceeckel.tools`中（自第5章開始創建）。為了將每個類都添加到庫內，只需將其置入適當的目錄，並添加對應的`package`語句即可。

(7) 快速文件輸入

若想創建一個對象，用它從一個緩衝的`DataInputStream`中讀取一個文件，可將這個過程封裝到一個名為`InFile`的類內。如下所示：

```
//: InFile.java
// Shorthand class for opening an input file
package com.bruceeckel.tools;
import java.io.*;

public class InFile extends DataInputStream {
  public InFile(String filename)
    throws FileNotFoundException {
    super(
      new BufferedInputStream(
        new FileInputStream(filename)));
  }
  public InFile(File file)
    throws FileNotFoundException {
    this(file.getPath());
  }
} ///:~
```

無論構造器的`String`版本還是`File`版本都包括在內，用於共同創建一個`FileInputStream`。

就象這個例子展示的那樣，現在可以有效減少創建文件時由於重複強調造成的問題。

(8) 快速輸出格式化文件

亦可用同類型的方法創建一個`PrintStream`，令其寫入一個緩衝文件。下面是對`com.bruceeckel.tools`的擴展：

```
//: PrintFile.java
// Shorthand class for opening an output file
// for human-readable output.
package com.bruceeckel.tools;
import java.io.*;

public class PrintFile extends PrintStream {
  public PrintFile(String filename)
    throws IOException {
    super(
      new BufferedOutputStream(
        new FileOutputStream(filename)));
  }
  public PrintFile(File file)
    throws IOException {
    this(file.getPath());
  }
} ///:~
```

注意構造器不可能捕獲一個由基類構造器“拋”出的異常。

(9) 快速輸出數據文件

最後，利用類似的快捷方式可創建一個緩衝輸出文件，用它保存數據（與由人觀看的數據格式相反）：

```
//: OutFile.java
// Shorthand class for opening an output file
// for data storage.
package com.bruceeckel.tools;
import java.io.*;

public class OutFile extends DataOutputStream {
  public OutFile(String filename)
    throws IOException {
    super(
      new BufferedOutputStream(
        new FileOutputStream(filename)));
  }
  public OutFile(File file)
    throws IOException {
    this(file.getPath());
  }
} ///:~
```

非常奇怪的是（也非常不幸），Java庫的設計者居然沒想到將這些便利措施直接作為他們的一部分標準提供。

## 10.5.4 從標準輸入中讀取數據

以Unix首先倡導的“標準輸入”、“標準輸出”以及“標準錯誤輸出”概念為基礎，Java提供了相應的`System.in`，`System.out`以及`System.err`。貫這一整本書，大家都會接觸到如何用`System.out`進行標準輸出，它已預封裝成一個`PrintStream`對象。

`System.err`同樣是一個`PrintStream`，但`System.in`是一個原始的`InputStream`，未進行任何封裝處理。這意味著儘管能直接使用`System.out`和`System.err`，但必須事先封裝`System.in`，否則不能從中讀取數據。

典型情況下，我們希望用`readLine()`每次讀取一行輸入信息，所以需要將`System.in`封裝到一個`DataInputStream`中。這是Java 1.0進行行輸入時採取的“老”辦法。在本章稍後，大家還會看到Java 1.1的解決方案。下面是個簡單的例子，作用是迴應我們鍵入的每一行內容：

```
//: Echo.java
// How to read from standard input
import java.io.*;

public class Echo {
  public static void main(String[] args) {
    DataInputStream in =
      new DataInputStream(
        new BufferedInputStream(System.in));
    String s;
    try {
      while((s = in.readLine()).length() != 0)
        System.out.println(s);
      // An empty line terminates the program
    } catch(IOException e) {
      e.printStackTrace();
    }
  }
} ///:~

```

之所以要使用`try`塊，是由於`readLine()`可能“拋”出一個`IOException`。注意同其他大多數流一樣，也應對`System.in`進行緩衝。

由於在每個程序中都要將`System.in`封裝到一個`DataInputStream`內，所以顯得有點不方便。但採用這種設計模式，可以獲得最大的靈活性。

## 10.5.5 管道數據流

本章已簡要介紹了`PipedInputStream`（管道輸入流）和`PipedOutputStream`（管道輸出流）。儘管描述不十分詳細，但並不是說它們作用不大。然而，只有在掌握了多線程處理的概念後，才可真正體會它們的價值所在。原因很簡單，因為管道化的數據流就是用於線程之間的通信。這方面的問題將在第14章用一個示例說明。
