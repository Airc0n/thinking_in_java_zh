# 15.2 套接字

“套接字”或者“插座”（`Socket`）也是一種軟件形式的抽象，用於表達兩臺機器間一個連接的“終端”。針對一個特定的連接，每臺機器上都有一個“套接字”，可以想象它們之間有一條虛擬的“線纜”。線纜的每一端都插入一個“套接字”或者“插座”裡。當然，機器之間的物理性硬件以及電纜連接都是完全未知的。抽象的基本宗旨是讓我們儘可能不必知道那些細節。

在Java中，我們創建一個套接字，用它建立與其他機器的連接。從套接字得到的結果是一個`InputStream`以及`OutputStream`（若使用恰當的轉換器，則分別是`Reader`和`Writer`），以便將連接作為一個IO流對象對待。有兩個基於數據流的套接字類：`ServerSocket`，服務器用它“監聽”進入的連接；以及`Socket`，客戶用它初始一次連接。一旦客戶（程序）申請建立一個套接字連接，`ServerSocket`就會返回（通過`accept()`方法）一個對應的服務器端套接字，以便進行直接通信。從此時起，我們就得到了真正的“套接字－套接字”連接，可以用同樣的方式對待連接的兩端，因為它們本來就是相同的！此時可以利用`getInputStream()`以及`getOutputStream()`從每個套接字產生對應的`InputStream`和`OutputStream`對象。這些數據流必須封裝到緩衝區內。可按第10章介紹的方法對類進行格式化，就象對待其他任何流對象那樣。

對於Java庫的命名機制，`ServerSocket`（服務器套接字）的使用無疑是容易產生混淆的又一個例證。大家可能認為`ServerSocket`最好叫作`ServerConnector`（服務器連接器），或者其他什麼名字，只是不要在其中安插一個`Socket`。也可能以為`ServerSocket`和`Socket`都應從一些通用的基類繼承。事實上，這兩種類確實包含了幾個通用的方法，但還不夠資格把它們賦給一個通用的基類。相反，`ServerSocket`的主要任務是在那裡耐心地等候其他機器同它連接，再返回一個實際的`Socket`。這正是`ServerSocket`這個命名不恰當的地方，因為它的目標不是真的成為一個`Socket`，而是在其他人同它連接的時候產生一個`Socket`對象。

然而，`ServerSocket`確實會在主機上創建一個物理性的“服務器”或者監聽用的套接字。這個套接字會監聽進入的連接，然後利用`accept()`方法返回一個“已建立”套接字（本地和遠程端點均已定義）。容易混淆的地方是這兩個套接字（監聽和已建立）都與相同的服務器套接字關聯在一起。監聽套接字只能接收新的連接請求，不能接收實際的數據包。所以儘管`ServerSocket`對於編程並無太大的意義，但它確實是“物理性”的。

創建一個`ServerSocket`時，只需為其賦予一個端口編號。不必把一個IP地址分配它，因為它已經在自己代表的那臺機器上了。但在創建一個`Socket`時，卻必須同時賦予IP地址以及要連接的端口編號（另一方面，從`ServerSocket.accept()`返回的`Socket`已經包含了所有這些信息）。

## 15.2.1 一個簡單的服務器和客戶端程序

這個例子將以最簡單的方式運用套接字對服務器和客戶端進行操作。服務器的全部工作就是等候建立一個連接，然後用那個連接產生的`Socket`創建一個`InputStream`以及一個`OutputStream`。在這之後，它從`InputStream`讀入的所有東西都會反饋給`OutputStream`，直到接收到行中止（END）為止，最後關閉連接。

客戶端連接與服務器的連接，然後創建一個`OutputStream`。文本行通過`OutputStream`發送。客戶端也會創建一個`InputStream`，用它收聽服務器說些什麼（本例只不過是反饋回來的同樣的字句）。

服務器與客戶端（程序）都使用同樣的端口號，而且客戶端利用本地主機地址連接位於同一臺機器中的服務器（程序），所以不必在一個物理性的網絡裡完成測試（在某些配置環境中，可能需要同真正的網絡建立連接，否則程序不能工作——儘管實際並不通過那個網絡通信）。

下面是服務器程序：

```
//: JabberServer.java
// Very simple server that just
// echoes whatever the client sends.
import java.io.*;
import java.net.*;

public class JabberServer {  
  // Choose a port outside of the range 1-1024:
  public static final int PORT = 8080;
  public static void main(String[] args)
      throws IOException {
    ServerSocket s = new ServerSocket(PORT);
    System.out.println("Started: " + s);
    try {
      // Blocks until a connection occurs:
      Socket socket = s.accept();
      try {
        System.out.println(
          "Connection accepted: "+ socket);
        BufferedReader in =
          new BufferedReader(
            new InputStreamReader(
              socket.getInputStream()));
        // Output is automatically flushed
        // by PrintWriter:
        PrintWriter out =
          new PrintWriter(
            new BufferedWriter(
              new OutputStreamWriter(
                socket.getOutputStream())),true);
        while (true) {  
          String str = in.readLine();
          if (str.equals("END")) break;
          System.out.println("Echoing: " + str);
          out.println(str);
        }
      // Always close the two sockets...
      } finally {
        System.out.println("closing...");
        socket.close();
      }
    } finally {
      s.close();
    }
  }
} ///:~
```

可以看到，`ServerSocket`需要的只是一個端口編號，不需要IP地址（因為它就在這臺機器上運行）。調用`accept()`時，方法會暫時陷入停頓狀態（堵塞），直到某個客戶嘗試同它建立連接。換言之，儘管它在那裡等候連接，但其他進程仍能正常運行（參考第14章）。建好一個連接以後，`accept()`就會返回一個`Socket`對象，它是那個連接的代表。

清除套接字的責任在這裡得到了很藝術的處理。假如`ServerSocket`構造器失敗，則程序簡單地退出（注意必須保證`ServerSocket`的構造器在失敗之後不會留下任何打開的網絡套接字）。針對這種情況，`main()`會“拋”出一個`IOException`異常，所以不必使用一個`try`塊。若`ServerSocket`構造器成功執行，則其他所有方法調用都必須到一個`try-finally`代碼塊裡尋求保護，以確保無論塊以什麼方式留下，`ServerSocket`都能正確地關閉。

同樣的道理也適用於由`accept()`返回的`Socket`。若`accept()`失敗，那麼我們必須保證`Socket`不再存在或者含有任何資源，以便不必清除它們。但假若執行成功，則後續的語句必須進入一個`try-finally`塊內，以保障在它們失敗的情況下，`Socket`仍能得到正確的清除。由於套接字使用了重要的非內存資源，所以在這裡必須特別謹慎，必須自己動手將它們清除（Java中沒有提供“析構器”來幫助我們做這件事情）。

無論`ServerSocket`還是由`accept()`產生的`Socket`都打印到`System.out`裡。這意味著它們的`toString`方法會得到自動調用。這樣便產生了：

```
ServerSocket[addr=0.0.0.0,PORT=0,localport=8080]
Socket[addr=127.0.0.1,PORT=1077,localport=8080]
```

大家不久就會看到它們如何與客戶程序做的事情配合。

程序的下一部分看來似乎僅僅是打開文件，以便讀取和寫入，只是`InputStream`和`OutputStream`是從`Socket`對象創建的。利用兩個“轉換器”類I`nputStreamReader`和`OutputStreamWriter`，`InputStream`和`OutputStream`對象已經分別轉換成為Java 1.1的`Reader`和`Writer`對象。也可以直接使用Java1.0的`InputStream`和`OutputStream`類，但對輸出來說，使用`Writer`方式具有明顯的優勢。這一優勢是通過`PrintWriter`表現出來的，它有一個重載的構造器，能獲取第二個參數——一個布爾值標誌，指向是否在每一次`println()`結束的時候自動刷新輸出（但不適用於`print()`語句）。每次寫入了輸出內容後（寫進`out`），它的緩衝區必須刷新，使信息能正式通過網絡傳遞出去。對目前這個例子來說，刷新顯得尤為重要，因為客戶和服務器在採取下一步操作之前都要等待一行文本內容的到達。若刷新沒有發生，那麼信息不會進入網絡，除非緩衝區滿（溢出），這會為本例帶來許多問題。

編寫網絡應用程序時，需要特別注意自動刷新機制的使用。每次刷新緩衝區時，必須創建和發出一個數據包（數據封）。就目前的情況來說，這正是我們所希望的，因為假如包內包含了還沒有發出的文本行，服務器和客戶端之間的相互“握手”就會停止。換句話說，一行的末尾就是一條消息的末尾。但在其他許多情況下，消息並不是用行分隔的，所以不如不用自動刷新機制，而用內建的緩衝區判決機制來決定何時發送一個數據包。這樣一來，我們可以發出較大的數據包，而且處理進程也能加快。

注意和我們打開的幾乎所有數據流一樣，它們都要進行緩衝處理。本章末尾有一個練習，清楚展現了假如我們不對數據流進行緩衝，那麼會得到什麼樣的後果（速度會變慢）。

無限`while`循環從`BufferedReader in`內讀取文本行，並將信息寫入`System.out`，然後寫入`PrintWriter.out`。注意這可以是任何數據流，它們只是在表面上同網絡連接。

客戶程序發出包含了`"END"`的行後，程序會中止循環，並關閉`Socket`。

下面是客戶程序的源碼：

```
//: JabberClient.java
// Very simple client that just sends
// lines to the server and reads lines
// that the server sends.
import java.net.*;
import java.io.*;

public class JabberClient {
  public static void main(String[] args)
      throws IOException {
    // Passing null to getByName() produces the
    // special "Local Loopback" IP address, for
    // testing on one machine w/o a network:
    InetAddress addr =
      InetAddress.getByName(null);
    // Alternatively, you can use
    // the address or name:
    // InetAddress addr =
    //    InetAddress.getByName("127.0.0.1");
    // InetAddress addr =
    //    InetAddress.getByName("localhost");
    System.out.println("addr = " + addr);
    Socket socket =
      new Socket(addr, JabberServer.PORT);
    // Guard everything in a try-finally to make
    // sure that the socket is closed:
    try {
      System.out.println("socket = " + socket);
      BufferedReader in =
        new BufferedReader(
          new InputStreamReader(
            socket.getInputStream()));
      // Output is automatically flushed
      // by PrintWriter:
      PrintWriter out =
        new PrintWriter(
          new BufferedWriter(
            new OutputStreamWriter(
              socket.getOutputStream())),true);
      for(int i = 0; i < 10; i ++) {
        out.println("howdy " + i);
        String str = in.readLine();
        System.out.println(str);
      }
      out.println("END");
    } finally {
      System.out.println("closing...");
      socket.close();
    }
  }
} ///:~
```

在`main()`中，大家可看到獲得本地主機IP地址的`InetAddress`的三種途徑：使用`null`，使用`localhost`，或者直接使用保留地址`127.0.0.1`。當然，如果想通過網絡同一臺遠程主機連接，也可以換用那臺機器的IP地址。打印出`InetAddress addr`後（通過對`toString()`方法的自動調用），結果如下：

```
localhost/127.0.0.1
```

通過向`getByName()`傳遞一個`null`，它會默認尋找`localhost`，並生成特殊的保留地址`127.0.0.1`。注意在名為`socket`的套接字創建時，同時使用了`InetAddress`以及端口號。打印這樣的某個`Socket`對象時，為了真正理解它的含義，請記住一次獨一無二的因特網連接是用下述四種數據標識的：`clientHost`（客戶主機）、`clientPortNumber`（客戶端口號）、`serverHost`（服務主機）以及`serverPortNumber`（服務端口號）。服務程序啟動後，會在本地主機（`127.0.0.1`）上建立為它分配的端口（8080）。一旦客戶程序發出請求，機器上下一個可用的端口就會分配給它（這種情況下是1077），這一行動也在與服務程序相同的機器（`127.0.0.1`）上進行。現在，為了使數據能在客戶及服務程序之間來回傳送，每一端都需要知道把數據發到哪裡。所以在同一個“已知”服務程序連接的時候，客戶會發出一個“返回地址”，使服務器程序知道將自己的數據發到哪兒。我們在服務器端的示範輸出中可以體會到這一情況：

```
Socket[addr=127.0.0.1,port=1077,localport=8080]
```

這意味著服務器剛才已接受了來自`127.0.0.1`這臺機器的端口1077的連接，同時監聽自己的本地端口（8080）。而在客戶端：

```
Socket[addr=localhost/127.0.0.1,PORT=8080,localport=1077]
```

這意味著客戶已用自己的本地端口1077與`127.0.0.1`機器上的端口8080建立了 連接。

大家會注意到每次重新啟動客戶程序的時候，本地端口的編號都會增加。這個編號從1025（剛好在系統保留的1-1024之外）開始，並會一直增加下去，除非我們重啟機器。若重新啟動機器，端口號仍然會從1025開始自增（在Unix機器中，一旦超過保留的套按字範圍，數字就會再次從最小的可用數字開始）。

創建好`Socket`對象後，將其轉換成`BufferedReader`和`PrintWriter的`過程便與在服務器中相同（同樣地，兩種情況下都要從一個`Socket`開始）。在這裡，客戶通過發出字符串`"howdy"`，並在後面跟隨一個數字，從而初始化通信。注意緩衝區必須再次刷新（這是自動發生的，通過傳遞給`PrintWriter`構造器的第二個參數）。若緩衝區沒有刷新，那麼整個會話（通信）都會被掛起，因為用於初始化的`"howdy"`永遠不會發送出去（緩衝區不夠滿，不足以造成發送動作的自動進行）。從服務器返回的每一行都會寫入`System.out`，以驗證一切都在正常運轉。為中止會話，需要發出一個`"END"`。若客戶程序簡單地掛起，那麼服務器會“拋”出一個異常。

大家在這裡可以看到我們採用了同樣的措施來確保由`Socket`代表的網絡資源得到正確的清除，這是用一個`try-finally`塊實現的。

套接字建立了一個“專用”連接，它會一直持續到明確斷開連接為止（專用連接也可能間接性地斷開，前提是某一端或者中間的某條鏈路出現故障而崩潰）。這意味著參與連接的雙方都被鎖定在通信中，而且無論是否有數據傳遞，連接都會連續處於開放狀態。從表面看，這似乎是一種合理的連網方式。然而，它也為網絡帶來了額外的開銷。本章後面會介紹進行連網的另一種方式。採用那種方式，連接的建立只是暫時的。
