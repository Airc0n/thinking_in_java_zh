# 14.7 練習


(1) 從`Thread`繼承一個類，並（重載）覆蓋`run()`方法。在`run()`內，打印出一條消息，然後調用`sleep()`。重複三遍這些操作，然後從`run()`返回。在構造器中放置一條啟動消息，並覆蓋`finalize()`，打印一條關閉消息。創建一個獨立的線程類，使它在`run()`內調用`System.gc()`和`System.runFinalization()`，並打印一條消息，表明調用成功。創建這兩種類型的幾個線程，然後運行它們，看看會發生什麼。

(2) 修改`Counter2.java`，使線程成為一個內部類，而且不需要明確保存指向`Counter2`的一個。

(3) 修改`Sharing2.java`，在`TwoCounter`的`run()`方法內部添加一個`synchronized`（同步）塊，而不是同步整個`run()`方法。

(4) 創建兩個`Thread`子類，第一個的`run()`方法用於最開始的啟動，並捕獲第二個`Thread`對象的引用，然後調用`wait()`。第二個類的`run()`應在過幾秒後為第一個線程調用`modifyAll()`，使第一個線程能打印出一條消息。

(5) 在`Ticker2`內的`Counter5.java`中，刪除`yield()`，並解釋一下結果。用一個`sleep()`換掉`yield()`，再解釋一下結果。

(6) 在`ThreadGroup1.java`中，將對`sys.suspend()`的調用換成對線程組的一個`wait()`調用，令其等候2秒鐘。為了保證獲得正確的結果，必須在一個同步塊內取得`sys`的對象鎖。

(7) 修改`Daemons.java`，使`main()`有一個`sleep()`，而不是一個`readLine()`。實驗不同的睡眠時間，看看會有什麼發生。

(8) 到第7章（中間部分）找到那個`GreenhouseControls.java`例子，它應該由三個文件構成。在`Event.java`中，`Event`類建立在對時間的監視基礎上。修改這個`Event`，使其成為一個線程。然後修改其餘的設計，使它們能與新的、以線程為基礎的Event正常協作。
