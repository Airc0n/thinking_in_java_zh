# 13.12 佈局的控制

在Java裡該方法是安一個組件到一個窗體中去，它不同我們使用過的其它GUI系統。首先，它是全代碼的；沒有控制安放組件的“資源”。其次，該方法的組件被安放到一個被“佈局管理器”控制的窗體中，由“佈局管理器”根據我們`add()`它們的決定來安放組件。大小，形狀，組件位置與其它系統的佈局管理器顯著的不同。另外，佈局管理器使我們的程序片或應用程序適合窗口的大小，所以，如果窗口的尺寸改變（例如，在HTML頁面的程序片指定的規格），組件的大小，形狀和位置都會改變。

程序片和幀類都是來源於包含和顯示組件的容器。（這個容器也是一個組件，所以它也能響應事件。）在容器中，調用`setLayout()`方法允許我選擇不同的佈局管理器。

在這節裡我們將探索不同的佈局管理器，並安放按鈕在它們之上。這裡沒有捕捉按鈕的事件，正好可以演示如何佈置這些按鈕。

## 13.12.1 `FlowLayout`

到目前為止，所有的程序片都被建立，看起來使用一些不可思議的內部邏輯來佈置它們的組件。那是因為程序使用一個默認的方式：`FlowLayout`。這個簡單的`Flow`的組件安裝在窗體中，從左到右，直到頂部的空格全部再移去一行，並繼續循環這些組件。

這裡有一個例子明確地（當然也是多餘地）設置一個程序片的佈局管理器去`FlowLayout`，然後在窗體中安放按鈕。我們將注意到`FlowLayout`組件使用它們本來的大小。例如一個按鈕將會變得和它的字符串符一樣的大小。

```
//: FlowLayout1.java
// Demonstrating the FlowLayout
import java.awt.*;
import java.applet.*;

public class FlowLayout1 extends Applet {
  public void init() {
    setLayout(new FlowLayout());
    for(int i = 0; i < 20; i++)
      add(new Button("Button " + i));
  }
} ///:~
```

所有組件將在`FlowLayout`中被壓縮為它們的最小尺寸，所以我們可能會得到一些奇怪的狀態。例如，一個標籤會合適它自已的字符串的尺寸，所以它會右對齊產生一個不變的顯示。

## 13.12.2 `BorderLayout`

佈局管理器有四邊和中間區域的概念。當我們增加一些事物到使用`BorderLayout`的面板上時我們必須使用`add()`方法將一個字符串對象作為它的第一個參數，並且字符串必須指定（正確的大寫）`North`（上），`South`（下），`west`（左），`East`（右）或者`Center`。如果我們拼寫錯誤或沒有大寫，就會得到一個編譯時的錯誤，並且程序片不會像你所期望的那樣運行。幸運的是，我們會很快發現在Java 1.1中有了更多改進。

這是一個簡單的程序例子：

```
//: BorderLayout1.java
// Demonstrating the BorderLayout
import java.awt.*;
import java.applet.*;

public class BorderLayout1 extends Applet {
  public void init() {
    int i = 0;
    setLayout(new BorderLayout());
    add("North", new Button("Button " + i++));
    add("South", new Button("Button " + i++));
    add("East", new Button("Button " + i++));
    add("West", new Button("Button " + i++));
    add("Center", new Button("Button " + i++));
  }
} ///:~
```

除了`Center`的每一個位置，當元素在其它空間內擴大到最大時，我們會把它壓縮到適合空間的最小尺寸。但是，`Center`擴大後只會佔據中心位置。

`BorderLayout`是應用程序和對話框的默認佈局管理器。

## 13.12.3 `GridLayout`

`GridLayout`允許我們建立一個組件表。添加那些組件時，它們會按從左到右、從上到下的順序在網格中排列。在構造器裡，需要指定自己希望的行、列數，它們將按正比例展開。

```
//: GridLayout1.java
// Demonstrating the GridLayout
import java.awt.*;
import java.applet.*;

public class GridLayout1 extends Applet {
  public void init() {
    setLayout(new GridLayout(7,3));
    for(int i = 0; i < 20; i++)
      add(new Button("Button " + i));
  }
} ///:~
```

在這個例子裡共有21個空位，但卻只有20個按鈕，最後的一個位置作留空處理；注意對`GridLayout`來說，並不存在什麼“均衡”處理。

## 13.12.4 `CardLayout`

`CardLayout`允許我們在更復雜的擁有真正的文件夾卡片與一條邊相遇的環境裡創建大致相同於“卡片式對話框”的佈局，我們必須壓下一個卡片使不同的對話框帶到前面來。在AWT裡不是這樣的：`CardLayout`是簡單的空的空格，我們可以自由地把新卡片帶到前面來。（JFC/Swing庫包括卡片式的窗格看起來非常的棒，且可以我們處理所有的細節。）

(1) 聯合佈局（Combining layouts)

下面的例子聯合了更多的佈局類型，在最初只有一個佈局管理器被程序片或應用程序操作看起來相當的困難。這是事實，但如果我們創建更多的面板對象，每個面板都能擁有一個佈局管理器，並且像被集成到程序片或應用程序中一樣使用程序片或應用程序的佈局管理器。這就象下面程序中的一樣給了我們更多的靈活性：

```
//: CardLayout1.java
// Demonstrating the CardLayout
import java.awt.*;
import java.applet.Applet;

class ButtonPanel extends Panel {
  ButtonPanel(String id) {
    setLayout(new BorderLayout());
    add("Center", new Button(id));
  }
}

public class CardLayout1 extends Applet {
  Button
    first = new Button("First"),
    second = new Button("Second"),
    third = new Button("Third");
  Panel cards = new Panel();
  CardLayout cl = new CardLayout();
  public void init() {
    setLayout(new BorderLayout());
    Panel p = new Panel();
    p.setLayout(new FlowLayout());
    p.add(first);
    p.add(second);
    p.add(third);
    add("North", p);
    cards.setLayout(cl);
    cards.add("First card",
      new ButtonPanel("The first one"));
    cards.add("Second card",
      new ButtonPanel("The second one"));
    cards.add("Third card",
      new ButtonPanel("The third one"));
    add("Center", cards);
  }
  public boolean action(Event evt, Object arg) {
    if (evt.target.equals(first)) {
      cl.first(cards);
    }
    else if (evt.target.equals(second)) {
      cl.first(cards);
      cl.next(cards);
    }
    else if (evt.target.equals(third)) {
      cl.last(cards);
    }
    else
      return super.action(evt, arg);
    return true;
  }
} ///:~
```

這個例子首先會創建一種新類型的面板：`BottonPanel`（按鈕面板）。它包括一個單獨的按鈕，安放在`BorderLayout`的中央，那意味著它將充滿整個的面板。按鈕上的標籤將讓我們知道我們在`CardLayout`上的那個面板上。

在程序片裡，面板卡片上將存放卡片和佈局管理器CL因為`CardLayout`必須組成類，因為當我們需要處理卡片時我們需要訪問這些引用。

這個程序片變成使用`BorderLayout`來取代它的默認`FlowLayout`，創建面板來容納三個按鈕（使用`FlowLayout`），並且這個面板安置在程序片末尾的`North`。卡片面板增加到程序片的`Center`裡，有效地佔據面板的其餘地方。

當我們增加`BottonPanels`(或者任何其它我們想要的組件）到卡片面板時，`add()`方法的第一個參數不是`North`，`South`等等。相反的是，它是一個描述卡片的字符串。如果我們想輕擊那張卡片使用字符串，我們就可以使用，雖然這字符串不會顯示在卡片的任何地方。使用的方法不是使用`action()`；代之使用`first()`、`next()`和`last()`等方法。請查看我們有關其它方法的文件。

在Java中，使用的一些卡片式面板結構十分的重要，因為（我們將在後面看到）在程序片編程中使用的彈出式對話框是十分令人沮喪的。對於Java 1.0版的程序片而言，`CardLayout`是唯一有效的取得很多不同的“彈出式”的窗體。

## 13.12.5 `GridBagLayout`

很早以前，人們相信所有的恆星、行星、太陽及月亮都圍繞地球公轉。這是直觀的觀察。但後來天文學家變得更加的精明，他們開始跟蹤個別星體的移動，它們中的一些似乎有時在軌道上緩慢運行。因為天文學家知道所有的天體都圍繞地球公轉，天文學家花費了大量的時間來討論相關的方程式和理論去解釋天體對象的運行。當我們試圖用`GridBagLayout`來工作時，我們可以想像自己為一個早期的天文學家。基礎的條例是（公告：有趣的是設計者居然在太陽上(這可能是在天體圖中標錯了位置所致，譯者注)）所有的天體都將遵守規則來運行。哥白尼日新說（又一次不顧嘲諷，發現太陽系內的所有的行星圍繞太陽公轉。）是使用網絡圖來判斷佈局，這種方法使得程序員的工作變得簡單。直到這些增加到Java裡，我們忍耐（持續的冷嘲熱諷）西班牙的`GridBagLayout`和`GridBagConstraints`狂熱宗教。我們建議廢止`GridBagLayout`。取代它的是，使用其它的佈局管理器和特殊的在單個程序裡聯合幾個面板使用不同的佈局管理器的技術。我們的程序片看起來不會有什麼不同；至少不足以調整`GridBagLayout`限制的麻煩。對我而言，通過一個例子來討論它實在是令人頭痛（並且我不鼓勵這種庫設計）。相反，我建議您從閱讀Cornell和Horstmann撰寫的《核心Java》（第二版，Prentice-Hall出版社，1997年）開始。

在這範圍內還有其它的：在JFC/Swing庫裡有一個新的使用Smalltalk的受人歡迎的“Spring and Struts”佈局管理器並且它能顯著地減少`GridBagLayout`的需要。
