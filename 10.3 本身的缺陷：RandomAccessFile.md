# 10.3 本身的缺陷：`RandomAccessFile`

`RandomAccessFile`用於包含了已知長度記錄的文件，以便我們能用`seek(`)從一條記錄移至另一條；然後讀取或修改那些記錄。各記錄的長度並不一定相同；只要知道它們有多大以及置於文件何處即可。

首先，我們有點難以相信`RandomAccessFile`不屬於`InputStream`或者`OutputStream`分層結構的一部分。除了恰巧實現了`DataInput`以及`DataOutput`（這兩者亦由`DataInputStream`和`DataOutputStream`實現）接口之外，它們與那些分層結構並無什麼關係。它甚至沒有用到現有`InputStream`或`OutputStream`類的功能——採用的是一個完全不相干的類。該類屬於全新的設計，含有自己的全部（大多數為固有）方法。之所以要這樣做，是因為`RandomAccessFile`擁有與其他IO類型完全不同的行為，因為我們可在一個文件裡向前或向後移動。不管在哪種情況下，它都是獨立運作的，作為`Object`的一個“直接繼承人”使用。

從根本上說，`RandomAccessFile`類似`DataInputStream`和`DataOutputStream`的聯合使用。其中，`getFilePointer()`用於瞭解當前在文件的什麼地方，`seek()`用於移至文件內的一個新地點，而`length()`用於判斷文件的最大長度。此外，構造器要求使用另一個參數（與C的`fopen()`完全一樣），指出自己只是隨機讀（`"r"`），還是讀寫兼施（`"rw"`）。這裡沒有提供對“只寫文件”的支持。也就是說，假如是從`DataInputStream`繼承的，那麼`RandomAccessFile`也有可能能很好地工作。

還有更難對付的。很容易想象我們有時要在其他類型的數據流中搜索，比如一個`ByteArrayInputStream`，但搜索方法只有`RandomAccessFile`才會提供。而後者只能針對文件才能操作，不能針對數據流操作。此時，`BufferedInputStream`確實允許我們標記一個位置（使用`mark()`，它的值容納於單個內部變量中），並用`reset()`重設那個位置。但這些做法都存在限制，並不是特別有用。
