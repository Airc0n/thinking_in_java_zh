# 13.2 基本程序片

庫通常按照它們的功能來進行組合。一些庫，例如使用過的，便中斷擱置起來。標準的Java庫字符串和向量類就是這樣的一個例子。其他的庫被特殊地設計，例如構建塊去建立其它的庫。庫中的某些類是應用程序的框架，其目的是協助我們構建應用程序，在提供類或類集的情況下產生每個特定應用程序的基本活動狀況。然後，為我們定製活動狀況，必須繼承應用程序類並且廢棄程序的權益。應用程序框架的默認控制結構將在特定的時間調用我們廢棄的程序。應用程序的框架是“分離、改變和中止事件”的好例子，因為它總是努力去嘗試集中在被廢棄的所有特殊程序段。

程序片利用應用程序框架來建立。我們從類中繼承程序片，並且廢棄特定的程序。大多數時間我們必須考慮一些不得不運行的使程序片在WEB頁面上建立和使用的重要方法。這些方法是：

```
Method

Operation

init( )

Called when the applet is first created to perform first-time initialization of the applet

start( )

Called every time the applet moves into sight on the Web browser to allow the applet to start up its normal operations (especially those that are shut off by stop( )). Also called after init( ).

paint( )

Part of the base class Component (three levels of inheritance up). Called as part of an update( ) to perform special painting on the canvas of an applet.

stop( )

Called every time the applet moves out of sight on the Web browser to allow the applet to shut off expensive operations. Also called right before destroy( ).

destroy( )

Called when the applet is being unloaded from the page to perform final release of resources when the applet is no longer used
```

| 方法 | 作用 |
| --- | --- |
| `init()` | 程序片第一次被創建，初次運行初始化程序片時調用 |
| `start()` | 每當程序片進入Web瀏覽器中，並且允許程序片啟動它的常規操作時調用（特殊的程序片被`stop()`關閉）；同樣在`init()`後調用 |
| `paint()` | 基類`Component`的一部分（繼承結構中上溯三級）。作為`update()`的一部分調用，以便對程序片的畫布進行特殊的描繪 |
| `stop()` | 每次程序片從Web瀏覽器的視線中離開時調用，使程序片能關閉代價高昂的操作；同樣在調用`destroy()`前調用 |
| `destroy()` | 程序片不再需要，將它從頁面中卸載時調用，以執行資源的最後清除工作 |

現在來看一看`paint()`方法。一旦`Component`（目前是程序片）決定自己需要更新，就會調用這個方法——可能是由於它再次迴轉屏幕，首次在屏幕上顯示，或者是由於其他窗口臨時覆蓋了你的Web瀏覽器。此時程序片會調用它的`update()`方法（在基類`Component中`定義），該方法會恢復一切該恢復的東西，而調用`paint()`正是這個過程的一部分。沒必要對`paint()`進行重載處理，但構建一個簡單的程序片無疑是方便的方法，所以我們首先從`paint()`方法開始。

`update()`調用`paint()`時，會向其傳遞指向`Graphics`對象的一個引用，那個對象代表準備在上面描繪（作圖）的表面。這是非常重要的，因為我們受到項目組件的外觀的限制，因此不能畫到區域外，這可是一件好事，否則我們就會畫到線外去。在程序片的例子中，程序片的外觀就是這界定的區域。

圖形對象同樣有一系列我們可對其進行的操作。這些操作都與在畫布上作圖有關。所以其中的大部分都要涉及圖像、幾何菜狀、圓弧等等的描繪（注意如果有興趣，可在Java文檔中找到更詳細的說明）。有些方法允許我們畫出字符，而其中最常用的就是`drawString()`。對於它，需指出自己想描繪的`String`（字符串），並指定它在程序片作圖區域的起點。這個位置用像素表示，所以它在不同的機器上看起來是不同的，但至少是可以移植的。

根據這些信息即可創建一個簡單的程序片：

```
//: Applet1.java
// Very simple applet
package c13;
import java.awt.*;
import java.applet.*;

public class Applet1 extends Applet {
  public void paint(Graphics g) {
    g.drawString("First applet", 10, 10);
  }
} ///:~
```

注意這個程序片不需要有一個`main()`。所有內容都封裝到應用程序框架中；我們將所有啟動代碼都放在`init()`裡。

必須將這個程序放到一個Web頁中才能運行，而只能在支持Java的Web瀏覽器中才能看到此頁。為了將一個程序片置入Web頁，需要在那個Web頁的代碼中設置一個特殊的標記（註釋①），以指示網頁裝載和運行程序片。這就是`applet`標記，它在`Applet1`中的樣子如下：

```
<applet
code=Applet1
width=200
height=200>
</applet>
```

①：本書假定讀者已掌握了HTML的基本知識。這些知識不難學習，有許多書籍和網上資源都可以提供幫助。

其中，`code`值指定了`.class`文件的名字，程序片就駐留在那個文件中。width和height指定這個程序片的初始尺寸（如前所述，以像素為單位）。還可將另一些東西放入`applet`標記：用於在因特網上尋找其他`.class`文件的位置（`codebase`）、對齊和排列信息（`align`）、使程序片相互間能夠通信的一個特殊標識符（`name`）以及用於提供程序片能接收的信息的參數。參數採取下述形式：

```
<Paramname=標識符 value ="信息">
```

可根據需要設置任意多個這樣的參數。

在簡單的程序片中，我們要做的唯一事情是按上述形式在Web頁中設置一個程序片標記（`applet`），令其裝載和運行程序片。

## 13.2.1 程序片的測試

我們可在不必建立網絡連接的前提下進行一次簡單的測試，方法是啟動我們的Web瀏覽器，然後打開包含了程序片標籤的HTML文件（Sun公司的JDK同樣包括一個稱為“程序片觀察器”的工具，它能挑出html文件的`<applet>`標記，並運行這個程序片，不必顯示周圍的HTML文本——註釋②）。html文件載入後，瀏覽器會發現程序片的標籤，並查找由`code`值指定的`.class`文件。當然，它會先在`CLASSPATH`（類路徑）中尋找，如果在`CLASSPATH`下找不到類文件，就在WEB瀏覽器狀態欄給出一個錯誤信息，告知不能找到`.class`文件。

②；由於程序片觀察器會忽略除`APPLET`標記之外的任何東西，所以可將那些標記作為註釋置入Java源碼：

```
// <applet code=MyApplet.class width=200 height=100></applet>
```

這樣就可直接執行`appletviewer MyApplet.java`，不必再創建小的HTML文件來完成測試。

若想在Web站點上試驗，還會碰到另一些麻煩。首先，我們必須有一個Web站點，這對大多數人來說都意味著位於遠程地點的一家服務提供商（ISP）。然後必須通過某種途徑將HTML文件和`.class`文件從自己的站點移至ISP機器上正確的目錄（WWW目錄）。這一般是通過採用“文件傳輸協議”（FTP）的程序來做成的，網上可找到許多這樣的免費程序。所以我們要做的全部事情似乎就是用FTP協議將文件移至ISP的機器，然後用自己的瀏覽器連接網站和HTML文件；假如程序片正確裝載和執行，就表明大功告成。但真是這樣嗎？

但這兒我們可能會受到愚弄。假如Web瀏覽器在服務器上找不到`.class`文件，就會在你的本地機器上搜尋`CLASSPATH`。所以程序片或許根本不能從服務器上正確地裝載，但在你看來卻是一切正常的，因為瀏覽器在你的機器上找到了它需要的東西。但在其他人訪問時，他們的瀏覽器就無法找到那些類文件。所以在測試時，必須確定已從自己的機器刪除了相關的`.class`文件，以確保測試結果的真實。

我自己就遇到過這樣的一個問題。當時是將程序片置入一個`package`（包）中。上載了HTML文件和程序片後，由於包名的問題，程序片的服務器路徑似乎陷入了混亂。但是，我的瀏覽器在本地類路徑（`CLASSPATH`）中找到了它。這樣一來，我就成了能夠成功裝載程序片的唯一一個人。後來我花了一些時間才發現原來是`package`語句有誤。一般地，應該將`package`語句置於程序片的外部。

## 13.2.2 一個更圖形化的例子

這個程序不會太令人緊張，所以讓我們試著增加一些有趣的圖形組件。

```
//: Applet2.java
// Easy graphics
import java.awt.*;
import java.applet.*;

public class Applet2 extends Applet {
  public void paint(Graphics g) {
    g.drawString("Second applet", 10, 15);
    g.draw3DRect(0, 0, 100, 20, true);
  }
} ///:~
```

這個程序用一個方框將字符串包圍起來。當然，所有數字都是“硬編碼”的（指數字固定於程序內部），並以像素為基礎。所以在一些機器上，框會正好將字符串圍住；而在另一些機器上，也許根本看不見這個框，因為不同機器安裝的字體也會有所區別。

對`Graphic`類而言，可在幫助文檔中找到另一些有趣的內容。大多數涉及圖形的活動都是很有趣的，所有我將更多的試驗留給讀者自己去進行。

## 13.2.3 框架方法的演示

觀看框架方法的實際運作是相當有趣的（這個例子只使用`init()`，`start()`和`stop()`，因為`paint()`和`destroy()`非常簡單，很容易就能掌握）。下面的程序片將跟蹤這些方法調用的次數，並用`paint()`將其顯示出來：

```
//: Applet3.java
// Shows init(), start() and stop() activities
import java.awt.*;
import java.applet.*;

public class Applet3 extends Applet {
  String s;
  int inits = 0;
  int starts = 0;
  int stops = 0;
  public void init() { inits++; }
  public void start() { starts++; }
  public void stop() { stops++; }
  public void paint(Graphics g) {
    s = "inits: " + inits +
      ", starts: " + starts +
      ", stops: " + stops;
    g.drawString(s, 10, 10);
  }
} ///:~
```

正常情況下，當我們重載一個方法時，需檢查自己是否需要調用方法的基類版本，這是十分重要的。例如，使用`init()`時可能需要調用`super.init()`。然而，`Applet`文檔特別指出`init()`、`start()`和`stop()`在`Applet`中沒有用處，所以這裡不需要調用它們。

試驗這個程序片時，會發現假如最小化WEB瀏覽器，或者用另一個窗口將其覆蓋，那麼就不能再調用`stop()`和`start()`（這一行為會隨著不同的實現方案變化；可考慮將Web瀏覽器的行為同程序片觀察器的行為對照一下）。調用唯一發生的場合是在我們轉移到一個不同的Web頁，然後返回包含了程序片的那個頁時。
