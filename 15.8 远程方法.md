# 15.8 遠程方法

為通過網絡執行其他機器上的代碼，傳統的方法不僅難以學習和掌握，也極易出錯。思考這個問題最佳的方式是：某些對象正好位於另一臺機器，我們可向它們發送一條消息，並獲得返回結果，就象那些對象位於自己的本地機器一樣。Java 1.1的“遠程方法調用”（RMI）採用的正是這種抽象。本節將引導大家經歷一些必要的步驟，創建自己的RMI對象。

## 15.8.1 遠程接口概念

RMI對接口有著強烈的依賴。在需要創建一個遠程對象的時候，我們通過傳遞一個接口來隱藏基層的實現細節。所以客戶得到遠程對象的一個引用時，它們真正得到的是接口引用。這個引用正好同一些本地的根代碼連接，由後者負責通過網絡通信。但我們並不關心這些事情，只需通過自己的接口引用發送消息即可。

創建一個遠程接口時，必須遵守下列規則：

(1) 遠程接口必須為`public`屬性（不能有“包訪問”；也就是說，它不能是“友好的”）。否則，一旦客戶試圖裝載一個實現了遠程接口的遠程對象，就會得到一個錯誤。

(2) 遠程接口必須擴展接口`java.rmi.Remote`。

(3) 除與應用程序本身有關的異常之外，遠程接口中的每個方法都必須在自己的throws從句中聲明`java.rmi.RemoteException`。

(4) 作為參數或返回值傳遞的一個遠程對象（不管是直接的，還是在本地對象中嵌入）必須聲明為遠程接口，不可聲明為實現類。

下面是一個簡單的遠程接口示例，它代表的是一個精確計時服務：

```
//: PerfectTimeI.java
// The PerfectTime remote interface
package c15.ptime;
import java.rmi.*;

interface PerfectTimeI extends Remote {
  long getPerfectTime() throws RemoteException;
} ///:~
```

它表面上與其他接口是類似的，只是對`Remote`進行了擴展，而且它的所有方法都會“拋”出`RemoteException`（遠程異常）。記住接口和它所有的方法都是`public`的。

## 15.8.2 遠程接口的實現

服務器必須包含一個擴展了`UnicastRemoteObject`的類，並實現遠程接口。這個類也可以含有附加的方法，但客戶只能使用遠程接口中的方法。這是顯然的，因為客戶得到的只是指向接口的一個引用，而非實現它的那個類。

必須為遠程對象明確定義構造器，即使只准備定義一個默認構造器，用它調用基類構造器。必須把它明確地編寫出來，因為它必須“拋”出`RemoteException`異常。

下面列出遠程接口`PerfectTime`的實現過程：

```
//: PerfectTime.java
// The implementation of the PerfectTime
// remote object
package c15.ptime;
import java.rmi.*;
import java.rmi.server.*;
import java.rmi.registry.*;
import java.net.*;

public class PerfectTime
    extends UnicastRemoteObject
    implements PerfectTimeI {
  // Implementation of the interface:
  public long getPerfectTime()
      throws RemoteException {
    return System.currentTimeMillis();
  }
  // Must implement constructor to throw
  // RemoteException:
  public PerfectTime() throws RemoteException {
    // super(); // Called automatically
  }
  // Registration for RMI serving:
  public static void main(String[] args) {
    System.setSecurityManager(
      new RMISecurityManager());
    try {
      PerfectTime pt = new PerfectTime();
      Naming.bind(
        "//colossus:2005/PerfectTime", pt);
      System.out.println("Ready to do time");
    } catch(Exception e) {
      e.printStackTrace();
    }
  }
} ///:~
```

在這裡，`main()`控制著設置服務器的全部細節。保存RMI對象時，必須在程序的某個地方採取下述操作：

(1) 創建和安裝一個安全管理器，令其支持RMI。作為Java發行包的一部分，適用於RMI唯一一個是`RMISecurityManager`。

(2) 創建遠程對象的一個或多個實例。在這裡，大家可看到創建的是`PerfectTime`對象。

(3) 向RMI遠程對象註冊表註冊至少一個遠程對象。一個遠程對象擁有的方法可生成指向其他遠程對象的引用。這樣一來，客戶只需到註冊表裡訪問一次，得到第一個遠程對象即可。

(1) 設置註冊表

在這兒，大家可看到對靜態方法`Naming.bind()`的一個調用。然而，這個調用要求註冊表作為計算機上的一個獨立進程運行。註冊表服務器的名字是`rmiregistry`。在32位Windows環境中，可使用：

```
start rmiregistry
```

令其在後臺運行。在Unix中，使用：

```
rmiregistry &
```

和許多網絡程序一樣，`rmiregistry`位於機器啟動它所在的某個IP地址處，但它也必須監視一個端口。如果象上面那樣調用`rmiregistry`，不使用參數，註冊表的端口就會默認為1099。若希望它位於其他某個端口，只需在命令行添加一個參數，指定那個端口編號即可。對這個例子來說，端口將位於2005，所以`rmiregistry`應該象下面這樣啟動（對於32位Windows）：

```
start rmiregistry 2005
```

對於Unix，則使用下述命令：

```
rmiregistry 2005 &
```

與端口有關的信息必須傳送給`bind()`命令，同時傳送的還有註冊表所在的那臺機器的IP地址。但假若我們想在本地測試RMI程序，就象本章的網絡程序一直測試的那樣，這樣做就會帶來問題。在JDK 1.1.1版本中，存在著下述兩方面的問題（註釋⑦）：

(1) `localhost`不能隨RMI工作。所以為了在單獨一臺機器上完成對RMI的測試，必須提供機器的名字。為了在32位Windows環境中調查自己機器的名字，可進入控制面板，選擇“網絡”，選擇“標識”卡片，其中列出了計算機的名字。就我自己的情況來說，我的機器叫作`Colossus`（因為我用幾個大容量的硬盤保存各種不同的開發系統——`Clossus`是“巨人”的意思）。似乎大寫形式會被忽略。

(2) 除非計算機有一個活動的TCP/IP連接，否則RMI不能工作，即使所有組件都只需要在本地機器裡互相通信。這意味著在試圖運行程序之前，必須連接到自己的ISP（因特網服務提供者），否則會得到一些含義模糊的異常消息。

⑦：為找出這些信息，我不知損傷了多少個腦細胞。

考慮到這些因素，`bind()`命令變成了下面這個樣子：

```
Naming.bind("//colossus:2005/PerfectTime", pt);
```

若使用默認端口1099，就沒有必要指定一個端口，所以可以使用：

```
Naming.bind("//colossus/PerfectTime", pt);
```

在JDK未來的版本中（1.1之後），一旦改正了`localhost`的問題，就能正常地進行本地測試，去掉IP地址，只使用標識符：

```
Naming.bind("PerfectTime", pt);
```

服務名是任意的；它在這裡正好為`PerfectTime`，和類名一樣，但你可以根據情況任意修改。最重要的是確保它在註冊表裡是個獨一無二的名字，以便客戶正常地獲取遠程對象。若這個名字已在註冊表裡了，就會得到一個`AlreadyBoundException`異常。為防止這個問題，可考慮堅持使用`rebind()`，放棄`bind()`。這是由於`rebind()`要麼會添加一個新條目，要麼將同名的條目替換掉。

儘管`main()`退出，我們的對象已經創建並註冊，所以會由註冊表一直保持活動狀態，等候客戶到達併發出對它的請求。只要`rmiregistry`處於運行狀態，而且我們沒有為名字調用`Naming.unbind()`方法，對象就肯定位於那個地方。考慮到這個原因，在我們設計自己的代碼時，需要先關閉`rmiregistry`，並在編譯遠程對象的一個新版本時重新啟動它。

並不一定要將`rmiregistry`作為一個外部進程啟動。若事前知道自己的是要求用以註冊表的唯一一個應用，就可在程序內部啟動它，使用下述代碼：

```
LocateRegistry.createRegistry(2005);
```

和前面一樣，2005代表我們在這個例子裡選用的端口號。這等價於在命令行執行`rmiregistry` 2005。但在設計RMI代碼時，這種做法往往顯得更加方便，因為它取消了啟動和中止註冊表所需的額外步驟。一旦執行完這個代碼，就可象以前一樣使用`Naming`進行“綁定”——`bind()`。

## 15.8.3 創建根與幹

若編譯和運行`PerfectTime.java`，即使`rmiregistry`正確運行，它也無法工作。這是由於RMI的框架尚未就位。首先必須創建根和幹，以便提供網絡連接操作，並使我們將遠程對象偽裝成自己機器內的某個本地對象。

所有這些幕後的工作都是相當複雜的。我們從遠程對象傳入、傳出的任何對象都必須`implement Serializable`（如果想傳遞遠程引用，而非整個對象，對象的參數就可以`implement Remote`）。因此可以想象，當根和幹通過網絡“彙集”所有參數並返回結果的時候，會自動進行序列化以及數據的重新裝配。幸運的是，我們根本沒必要了解這些方面的任何細節，但根和幹卻是必須創建的。一個簡單的過程如下：在編譯好的代碼中調用`rmic`，它會創建必需的一些文件。所以唯一要做的事情就是為編譯過程新添一個步驟。

然而，`rmic`工具與特定的包和類路徑有很大的關聯。`PerfectTime.java`位於包`c15.Ptime`中，即使我們調用與`PerfectTime.class`同一目錄內的`rmic`，`rmic`都無法找到文件。這是由於它搜索的是類路徑。因此，我們必須同時指定類路徑，就象下面這樣：

```
rmic c15.PTime.PerfectTime
```

執行這個命令時，並不一定非要在包含了`PerfectTime.class`的目錄中，但結果會置於當前目錄。
若`rmic`成功運行，目錄裡就會多出兩個新類：

```
PerfectTime_Stub.class
PerfectTime_Skel.class
```

它們分別對應根（`Stub`）和幹（`Skeleton`）。現在，我們已準備好讓服務器與客戶互相溝通了。

## 15.8.4 使用遠程對象

RMI全部的宗旨就是儘可能簡化遠程對象的使用。我們在客戶程序中要做的唯一一件額外的事情就是查找並從服務器取回遠程接口。自此以後，剩下的事情就是普通的Java編程：將消息發給對象。下面是使用`PerfectTime`的程序：

```
//: DisplayPerfectTime.java
// Uses remote object PerfectTime
package c15.ptime;
import java.rmi.*;
import java.rmi.registry.*;

public class DisplayPerfectTime {
  public static void main(String[] args) {
    System.setSecurityManager(
      new RMISecurityManager());
    try {
      PerfectTimeI t =
        (PerfectTimeI)Naming.lookup(
          "//colossus:2005/PerfectTime");
      for(int i = 0; i < 10; i++)
        System.out.println("Perfect time = " +
          t.getPerfectTime());
    } catch(Exception e) {
      e.printStackTrace();
    }
  }
} ///:~
```

ID字符串與那個用`Naming`註冊對象的那個字符串是相同的，第一部分指出了URL和端口號。由於我們準備使用一個URL，所以也可以指定因特網上的一臺機器。

從`Naming.lookup()`返回的必須轉換到遠程接口，而不是到類。若換用類，會得到一個異常提示。
在下述方法調用中：

```
t.getPerfectTime( )
```

我們可看到一旦獲得遠程對象的引用，用它進行的編程與用本地對象的編程是非常相似（僅有一個區別：遠程方法會“拋”出一個`RemoteException`異常）。

## 15.8.5 RMI的替選方案

RMI只是一種創建特殊對象的方式，它創建的對象可通過網絡發佈。它最大的優點就是提供了一種“純Java”方案，但假如已經有許多用其他語言編寫的代碼，則RMI可能無法滿足我們的要求。目前，兩種最具競爭力的替選方案是微軟的DCOM（根據微軟的計劃，它最終會移植到除Windows以外的其他平臺）以及CORBA。CORBA自Java 1.1便開始支持，是一種全新設計的概念，面向跨平臺應用。在由Orfali和Harkey編著的《Client/Server Programming with Java and CORBA》一書中（John Wiley&Sons 1997年出版），大家可獲得對Java中的分佈式對象的全面介紹（該書似乎對CORBA似乎有些偏見）。為CORBA賦予一個較公正的對待的一本書是由Andreas Vogel和Keith Duddy編寫的《Java Programming with CORBA》，John Wiley&Sons於1997年出版。
