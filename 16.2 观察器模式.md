# 16.2 觀察器模式

觀察器（`Observer`）模式解決的是一個相當普通的問題：由於某些對象的狀態發生了改變，所以一組對象都需要更新，那麼該如何解決？在Smalltalk的MVC（模型－視圖－控制器）的“模型－視圖”部分中，或在幾乎等價的“文檔－視圖結構”中，大家可以看到這個問題。現在我們有一些數據（“文檔”）以及多個視圖，假定為一張圖（`Plot`）和一個文本視圖。若改變了數據，兩個視圖必須知道對自己進行更新，而那正是“觀察器”要負責的工作。這是一種十分常見的問題，它的解決方案已包括進標準的`java.util`庫中。

在Java中，有兩種類型的對象用來實現觀察器模式。其中，`Observable`類用於跟蹤那些當發生一個改變時希望收到通知的所有個體——無論“狀態”是否改變。如果有人說“好了，所有人都要檢查自己，並可能要進行更新”，那麼`Observable`類會執行這個任務——為列表中的每個“人”都調用`notifyObservers()`方法。`notifyObservers()`方法屬於基類`Observable`的一部分。

在觀察器模式中，實際有兩個方面可能發生變化：觀察對象的數量以及更新的方式。也就是說，觀察器模式允許我們同時修改這兩個方面，不會干擾圍繞在它周圍的其他代碼。

下面這個例子類似於第14章的`ColorBoxes`示例。箱子（`Boxes`）置於一個屏幕網格中，每個都初始化一種隨機的顏色。此外，每個箱子都“實現”（`implement`）了“觀察器”（`Observer`）接口，而且隨一個`Observable`對象進行了註冊。若點擊一個箱子，其他所有箱子都會收到一個通知，指出一個改變已經發生。這是由於`Observable`對象會自動調用每個`Observer`對象的`update()`方法。在這個方法內，箱子會檢查被點中的那個箱子是否與自己緊鄰。若答案是肯定的，那麼也修改自己的顏色，保持與點中那個箱子的協調。

```
//: BoxObserver.java
// Demonstration of Observer pattern using
// Java's built-in observer classes.
import java.awt.*;
import java.awt.event.*;
import java.util.*;

// You must inherit a new type of Observable:
class BoxObservable extends Observable {
  public void notifyObservers(Object b) {
    // Otherwise it won't propagate changes:
    setChanged();
    super.notifyObservers(b);
  }
}

public class BoxObserver extends Frame {
  Observable notifier = new BoxObservable();
  public BoxObserver(int grid) {
    setTitle("Demonstrates Observer pattern");
    setLayout(new GridLayout(grid, grid));
    for(int x = 0; x < grid; x++)
      for(int y = 0; y < grid; y++)
        add(new OCBox(x, y, notifier));
  }   
  public static void main(String[] args) {
    int grid = 8;
    if(args.length > 0)
      grid = Integer.parseInt(args[0]);
    Frame f = new BoxObserver(grid);
    f.setSize(500, 400);
    f.setVisible(true);
    f.addWindowListener(
      new WindowAdapter() {
        public void windowClosing(WindowEvent e) {
          System.exit(0);
        }
      });
  }
}

class OCBox extends Canvas implements Observer {
  Observable notifier;
  int x, y; // Locations in grid
  Color cColor = newColor();
  static final Color[] colors = {
    Color.black, Color.blue, Color.cyan,
    Color.darkGray, Color.gray, Color.green,
    Color.lightGray, Color.magenta,
    Color.orange, Color.pink, Color.red,
    Color.white, Color.yellow
  };
  static final Color newColor() {
    return colors[
      (int)(Math.random() * colors.length)
    ];
  }
  OCBox(int x, int y, Observable notifier) {
    this.x = x;
    this.y = y;
    notifier.addObserver(this);
    this.notifier = notifier;
    addMouseListener(new ML());
  }
  public void paint(Graphics  g) {
    g.setColor(cColor);
    Dimension s = getSize();
    g.fillRect(0, 0, s.width, s.height);
  }
  class ML extends MouseAdapter {
    public void mousePressed(MouseEvent e) {
      notifier.notifyObservers(OCBox.this);
    }
  }
  public void update(Observable o, Object arg) {
    OCBox clicked = (OCBox)arg;
    if(nextTo(clicked)) {
      cColor = clicked.cColor;
      repaint();
    }
  }
  private final boolean nextTo(OCBox b) {
    return Math.abs(x - b.x) <= 1 &&
           Math.abs(y - b.y) <= 1;
  }
} ///:~
```

如果是首次查閱`Observable`的聯機幫助文檔，可能會多少感到有些困惑，因為它似乎表明可以用一個原始的`Observable`對象來管理更新。但這種說法是不成立的；大家可自己試試——在`BoxObserver`中，創建一個`Observable`對象，替換`BoxObservable`對象，看看會有什麼事情發生。事實上，什麼事情也不會發生。為真正產生效果，必須從`Observable`繼承，並在派生類代碼的某個地方調用`setChanged()`。這個方法需要設置`changed`（已改變）標誌，它意味著當我們調用`notifyObservers()`的時候，所有觀察器事實上都會收到通知。在上面的例子中，`setChanged()`只是簡單地在`notifyObservers()`中調用，大家可依據符合實際情況的任何標準決定何時調用`setChanged()`。

`BoxObserver`包含了單個`Observable`對象，名為`notifier`。每次創建一個`OCBox`對象時，它都會同`notifier`聯繫到一起。在`OCBox`中，只要點擊鼠標，就會發出對`notifyObservers()`方法的調用，並將被點中的那個對象作為一個參數傳遞進去，使收到消息（用它們的`update()`方法）的所有箱子都能知道誰被點中了，並據此判斷自己是否也要變動。通過`notifyObservers()`和`update()`中的代碼的結合，我們可以應付一些非常複雜的局面。

在`notifyObservers()`方法中，表面上似乎觀察器收到通知的方式必須在編譯期間固定下來。然而，只要稍微仔細研究一下上面的代碼，就會發現`BoxObserver`或`OCBox`中唯一需要留意是否使用`BoxObservable`的地方就是創建`Observable`對象的時候——從那時開始，所有東西都會使用基本的`Observable`接口。這意味著以後若想更改通知方式，可以繼承其他`Observable`類，並在運行期間交換它們。
