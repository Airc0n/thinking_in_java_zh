# 2.3 絕對不要清除對象


在大多數程序設計語言中，變量的“存在時間”（Lifetime）一直是程序員需要著重考慮的問題。變量應持續多長的時間？如果想清除它，那麼何時進行？在變量存在時間上糾纏不清會造成大量的程序錯誤。在下面的小節裡，將闡示Java如何幫助我們完成所有清除工作，從而極大了簡化了這個問題。

## 2.3.1 作用域

大多數程序設計語言都提供了“作用域”（Scope）的概念。對於在作用域裡定義的名字，作用域同時決定了它的“可見性”以及“存在時間”。在C，C++和Java裡，作用域是由花括號的位置決定的。參考下面這個例子：

```
{
  int x = 12;
  /* only x available */
  {
    int q = 96;
    /* both x & q available */
  }
  /* only x available */
  /* q “out of scope” */
}
```

作為在作用域裡定義的一個變量，它只有在那個作用域結束之前才可使用。

在上面的例子中，縮進排版使Java代碼更易辨讀。由於Java是一種形式自由的語言，所以額外的空格、製表位以及回車都不會對結果程序造成影響。

注意儘管在C和C++裡是合法的，但在Java裡不能象下面這樣書寫代碼：

```
{
  int x = 12;
  {
    int x = 96; /* illegal */
  }
}
```

編譯器會認為變量`x`已被定義。所以C和C++能將一個變量“隱藏”在一個更大的作用域裡。但這種做法在Java裡是不允許的，因為Java的設計者認為這樣做使程序產生了混淆。

## 2.3.2 對象的作用域

Java對象不具備與基本類型一樣的存在時間。用`new`關鍵字創建一個Java對象的時候，它會超出作用域的範圍之外。所以假若使用下面這段代碼：

```
{
String s = new String("a string");
} /* 作用域的終點 */
```

那麼引用`s`會在作用域的終點處消失。然而，`s`指向的`String`對象依然佔據著內存空間。在上面這段代碼裡，我們沒有辦法訪問對象，因為指向它的唯一一個引用已超出了作用域的邊界。在後面的章節裡，大家還會繼續學習如何在程序運行期間傳遞和複製對象引用。

這樣造成的結果便是：對於用`new`創建的對象，只要我們願意，它們就會一直保留下去。這個編程問題在C和C++裡特別突出。看來在C++裡遇到的麻煩最大：由於不能從語言獲得任何幫助，所以在需要對象的時候，根本無法確定它們是否可用。而且更麻煩的是，在C++裡，一旦工作完成，必須保證將對象清除。

這樣便帶來了一個有趣的問題。假如Java讓對象依然故我，怎樣才能防止它們大量充斥內存，並最終造成程序的“凝固”呢。在C++裡，這個問題最令程序員頭痛。但Java以後，情況卻發生了改觀。Java有一個特別的“垃圾收集器”，它會查找用new創建的所有對象，並辨別其中哪些不再被引用。隨後，它會自動釋放由那些閒置對象佔據的內存，以便能由新對象使用。這意味著我們根本不必操心內存的回收問題。只需簡單地創建對象，一旦不再需要它們，它們就會自動離去。這樣做可防止在C++裡很常見的一個編程問題：由於程序員忘記釋放內存造成的“內存溢出”。
