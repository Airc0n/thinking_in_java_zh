# 14.5 回顧runnable


在本章早些時候，我曾建議大家在將一個程序片或主`Frame`當作`Runnable`的實現形式之前，一定要好好地想一想。若採用那種方式，就只能在自己的程序中使用其中的一個線程。這便限制了靈活性，一旦需要用到屬於那種類型的多個線程，就會遇到不必要的麻煩。

當然，如果必須從一個類繼承，而且想使類具有線程處理能力，則`Runnable`是一種正確的方案。本章最後一個例子對這一點進行了剖析，製作了一個`RunnableCanvas`類，用於為自己描繪不同的顏色（`Canvas`是“畫布”的意思）。這個應用被設計成從命令行獲得參數值，以決定顏色網格有多大，以及顏色發生變化之間的`sleep()`有多長。通過運用這些值，大家能體驗到線程一些有趣而且可能令人費解的特性：

```
//: ColorBoxes.java
// Using the Runnable interface
import java.awt.*;
import java.awt.event.*;

class CBox extends Canvas implements Runnable {
  private Thread t;
  private int pause;
  private static final Color[] colors = {
    Color.black, Color.blue, Color.cyan,
    Color.darkGray, Color.gray, Color.green,
    Color.lightGray, Color.magenta,
    Color.orange, Color.pink, Color.red,
    Color.white, Color.yellow
  };
  private Color cColor = newColor();
  private static final Color newColor() {
    return colors[
      (int)(Math.random() * colors.length)
    ];
  }
  public void paint(Graphics  g) {
    g.setColor(cColor);
    Dimension s = getSize();
    g.fillRect(0, 0, s.width, s.height);
  }
  public CBox(int pause) {
    this.pause = pause;
    t = new Thread(this);
    t.start();
  }
  public void run() {
    while(true) {
      cColor = newColor();
      repaint();
      try {
        t.sleep(pause);
      } catch(InterruptedException e) {}
    }
  }
}

public class ColorBoxes extends Frame {
  public ColorBoxes(int pause, int grid) {
    setTitle("ColorBoxes");
    setLayout(new GridLayout(grid, grid));
    for (int i = 0; i < grid * grid; i++)
      add(new CBox(pause));
    addWindowListener(new WindowAdapter() {
      public void windowClosing(WindowEvent e) {
        System.exit(0);
      }
    });
  }   
  public static void main(String[] args) {
    int pause = 50;
    int grid = 8;
    if(args.length > 0)
      pause = Integer.parseInt(args[0]);
    if(args.length > 1)
      grid = Integer.parseInt(args[1]);
    Frame f = new ColorBoxes(pause, grid);
    f.setSize(500, 400);
    f.setVisible(true);  
  }
} ///:~
```

`ColorBoxes`是一個典型的應用（程序），有一個構造器用於設置GUI。這個構造器採用`int grid`的一個參數，用它設置`GridLayout`（網格佈局），使每一維裡都有一個`grid`單元。隨後，它添加適當數量的`CBox`對象，用它們填充網格，併為每一個都傳遞`pause`值。在`main()`中，我們可看到如何對`pause`和`grid`的默認值進行修改（如果用命令行參數傳遞）。

`CBox`是進行正式工作的地方。它是從`Canvas`繼承的，並實現了`Runnable`接口，使每個`Canvas`也能是一個`Thread`。記住在實現`Runnable`的時候，並沒有實際產生一個`Thread`對象，只是一個擁有`run()`方法的類。因此，我們必須明確地創建一個`Thread`對象，並將`Runnable`對象傳遞給構造器，隨後調用`start()`（在構造器裡進行）。在`CBox`裡，這個線程的名字叫作`t`。

請留意數組`colors`，它對`Color`類中的所有顏色進行了列舉（枚舉）。它在`newColor()`中用於產生一種隨機選擇的顏色。當前的單元（格）顏色是`cColor`。

`paint()`則相當簡單——只是將顏色設為`cColor`，然後用那種顏色填充整張畫布（`Canvas`）。

在`run()`中，我們看到一個無限循環，它將`cColor`設為一種隨機顏色，然後調用`repaint()`把它顯示出來。隨後，對線程執行`sleep()`，使其“休眠”由命令行指定的時間長度。

由於這種設計模式非常靈活，而且線程處理同每個`Canvas`元素都緊密結合在一起，所以在理論上可以生成任意多的線程（但在實際應用中，這要受到JVM能夠從容對付的線程數量的限制）。

這個程序也為我們提供了一個有趣的評測基準，因為它揭示了不同JVM機制在速度上造成的戲劇性的差異。

## 14.5.1 過多的線程

有些時候，我們會發現`ColorBoxes`幾乎陷於停頓狀態。在我自己的機器上，這一情況在產生了`10×10`的網格之後發生了。為什麼會這樣呢？自然地，我們有理由懷疑AWT對它做了什麼事情。所以這裡有一個例子能夠測試那個猜測，它產生了較少的線程。代碼經過了重新組織，使一個`Vector`實現了`Runnable`，而且那個`Vector`容納了數量眾多的色塊，並隨機挑選一些進行更新。隨後，我們創建大量這些`Vector`對象，數量大致取決於我們挑選的網格維數。結果便是我們得到比色塊少得多的線程。所以假如有一個速度的加快，我們就能立即知道，因為前例的線程數量太多了。如下所示：

```
//: ColorBoxes2.java
// Balancing thread use
import java.awt.*;
import java.awt.event.*;
import java.util.*;

class CBox2 extends Canvas {
  private static final Color[] colors = {
    Color.black, Color.blue, Color.cyan,
    Color.darkGray, Color.gray, Color.green,
    Color.lightGray, Color.magenta,
    Color.orange, Color.pink, Color.red,
    Color.white, Color.yellow
  };
  private Color cColor = newColor();
  private static final Color newColor() {
    return colors[
      (int)(Math.random() * colors.length)
    ];
  }
  void nextColor() {
    cColor = newColor();
    repaint();
  }
  public void paint(Graphics  g) {
    g.setColor(cColor);
    Dimension s = getSize();
    g.fillRect(0, 0, s.width, s.height);
  }
}

class CBoxVector
  extends Vector implements Runnable {
  private Thread t;
  private int pause;
  public CBoxVector(int pause) {
    this.pause = pause;
    t = new Thread(this);
  }
  public void go() { t.start(); }
  public void run() {
    while(true) {
      int i = (int)(Math.random() * size());
      ((CBox2)elementAt(i)).nextColor();
      try {
        t.sleep(pause);
      } catch(InterruptedException e) {}
    }
  }
}

public class ColorBoxes2 extends Frame {
  private CBoxVector[] v;
  public ColorBoxes2(int pause, int grid) {
    setTitle("ColorBoxes2");
    setLayout(new GridLayout(grid, grid));
    v = new CBoxVector[grid];
    for(int i = 0; i < grid; i++)
      v[i] = new CBoxVector(pause);
    for (int i = 0; i < grid * grid; i++) {
      v[i % grid].addElement(new CBox2());
      add((CBox2)v[i % grid].lastElement());
    }
    for(int i = 0; i < grid; i++)
      v[i].go();
    addWindowListener(new WindowAdapter() {
      public void windowClosing(WindowEvent e) {
        System.exit(0);
      }
    });
  }   
  public static void main(String[] args) {
    // Shorter default pause than ColorBoxes:
    int pause = 5;
    int grid = 8;
    if(args.length > 0)
      pause = Integer.parseInt(args[0]);
    if(args.length > 1)
      grid = Integer.parseInt(args[1]);
    Frame f = new ColorBoxes2(pause, grid);
    f.setSize(500, 400);
    f.setVisible(true);  
  }
} ///:~
```

在`ColorBoxes2`中，我們創建了`CBoxVector`的一個數組，並對其初始化，使其容下各個`CBoxVector`網格。每個網格都知道自己該“睡眠”多長的時間。隨後為每個`CBoxVector`都添加等量的`Cbox2`對象，而且將每個`Vector`都告訴給`go()`，用它來啟動自己的線程。

`CBox2`類似`CBox`——能用一種隨機選擇的顏色描繪自己。但那就是`CBox2`能夠做的全部工作。所有涉及線程的處理都已移至`CBoxVector`進行。

`CBoxVector`也可以擁有繼承的`Thread`，並有一個類型為`Vector`的成員對象。這樣設計的好處就是`addElement()`和`elementAt()`方法可以獲得特定的參數以及返回值類型，而不是隻能獲得常規Object（它們的名字也可以變得更短）。然而，這裡採用的設計表面上看需要較少的代碼。除此以外，它會自動保留一個`Vector`的其他所有行為。由於`elementAt()`需要大量進行“封閉”工作，用到許多括號，所以隨著代碼主體的擴充，最終仍有可能需要大量代碼。

和以前一樣，在我們實現`Runnable`的時候，並沒有獲得與`Thread`配套提供的所有功能，所以必須創建一個新的`Thread`，並將自己傳遞給它的構造器，以便正式“啟動”——`start()`——一些東西。大家在`CBoxVector`構造器和`go()`裡都可以體會到這一點。`run()`方法簡單地選擇`Vector`裡的一個隨機元素編號，併為那個元素調用`nextColor()`，令其挑選一種新的隨機顏色。

運行這個程序時，大家會發現它確實變得更快，響應也更迅速（比如在中斷它的時候，它能更快地停下來）。而且隨著網格尺寸的壯大，它也不會經常性地陷於“停頓”狀態。因此，線程的處理又多了一項新的考慮因素：必須隨時檢查自己有沒有“太多的線程”（無論對什麼程序和運行平臺）。若線程太多，必須試著使用上面介紹的技術，對程序中的線程數量進行“平衡”。如果在一個多線程的程序中遇到了性能上的問題，那麼現在有許多因素需要檢查：

(1) 對`sleep`，`yield()`以及／或者`wait()`的調用足夠多嗎？

(2) `sleep()`的調用時間足夠長嗎？

(3) 運行的線程數是不是太多？

(4) 試過不同的平臺和JVM嗎？

象這樣的一些問題是造成多線程應用程序的編製成為一種“技術活”的原因之一。
