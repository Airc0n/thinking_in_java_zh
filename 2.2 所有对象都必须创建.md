# 2.2 所有對象都必須創建


創建引用時，我們希望它同一個新對象連接。通常用`new`關鍵字達到這一目的。`new`的意思是：“把我變成這些對象的一種新類型”。所以在上面的例子中，可以說：

```
String s = new String("asdf");
```

它不僅指出“將我變成一個新字符串”，也通過提供一個初始字符串，指出了“如何生成這個新字符串”。

當然，字符串（`String`）並非唯一的類型。Java配套提供了數量眾多的現成類型。對我們來講，最重要的就是記住能自行創建類型。事實上，這應是Java程序設計的一項基本操作，是繼續本書後餘部分學習的基礎。

## 2.2.1 保存到什麼地方

程序運行時，我們最好對數據保存到什麼地方做到心中有數。特別要注意的是內存的分配。有六個地方都可以保存數據：

(1) 寄存器。這是最快的保存區域，因為它位於和其他所有保存方式不同的地方：處理器內部。然而，寄存器的數量十分有限，所以寄存器是根據需要由編譯器分配。我們對此沒有直接的控制權，也不可能在自己的程序裡找到寄存器存在的任何蹤跡。

(2) 棧。駐留於常規RAM（隨機訪問存儲器）區域，但可通過它的“棧指針”獲得處理的直接支持。棧指針若向下移，會創建新的內存；若向上移，則會釋放那些內存。這是一種特別快、特別有效的數據保存方式，僅次於寄存器。創建程序時，Java編譯器必須準確地知道棧內保存的所有數據的“長度”以及“存在時間”。這是由於它必須生成相應的代碼，以便向上和向下移動指針。這一限制無疑影響了程序的靈活性，所以儘管有些Java數據要保存在棧裡——特別是對象引用，但Java對象並不放到其中。

(3) 堆。一種常規用途的內存池（也在RAM區域），其中保存了Java對象。和棧不同，“內存堆”或“堆”（Heap）最吸引人的地方在於編譯器不必知道要從堆裡分配多少存儲空間，也不必知道存儲的數據要在堆裡停留多長的時間。因此，用堆保存數據時會得到更大的靈活性。要求創建一個對象時，只需用new命令編制相關的代碼即可。執行這些代碼時，會在堆裡自動進行數據的保存。當然，為達到這種靈活性，必然會付出一定的代價：在堆裡分配存儲空間時會花掉更長的時間！

(4) 靜態存儲。這兒的“靜態”（`Static`）是指“位於固定位置”（儘管也在RAM裡）。程序運行期間，靜態存儲的數據將隨時等候調用。可用`static`關鍵字指出一個對象的特定元素是靜態的。但Java對象本身永遠都不會置入靜態存儲空間。

(5) 常數存儲。常數值通常直接置於程序代碼內部。這樣做是安全的，因為它們永遠都不會改變。有的常數需要嚴格地保護，所以可考慮將它們置入只讀存儲器（ROM）。

(6) 非RAM存儲。若數據完全獨立於一個程序之外，則程序不運行時仍可存在，並在程序的控制範圍之外。其中兩個最主要的例子便是“流式對象”和“固定對象”。對於流式對象，對象會變成字節流，通常會發給另一臺機器。而對於固定對象，對象保存在磁盤中。即使程序中止運行，它們仍可保持自己的狀態不變。對於這些類型的數據存儲，一個特別有用的技巧就是它們能存在於其他媒體中。一旦需要，甚至能將它們恢復成普通的、基於RAM的對象。Java 1.1提供了對Lightweight persistence的支持。未來的版本甚至可能提供更完整的方案。

## 2.2.2 特殊情況：基本類型

有一系列類需特別對待；可將它們想象成“基本”、“主要”或者“主”（Primitive）類型，進行程序設計時要頻繁用到它們。之所以要特別對待，是由於用`new`創建對象（特別是小的、簡單的變量）並不是非常有效，因為`new`將對象置於“堆”裡。對於這些類型，Java採納了與C和C++相同的方法。也就是說，不是用`new`創建變量，而是創建一個並非引用的“自動”變量。這個變量容納了具體的值，並置於棧中，能夠更高效地存取。

Java決定了每種主要類型的大小。就象在大多數語言裡那樣，這些大小並不隨著機器結構的變化而變化。這種大小的不可更改正是Java程序具有很強移植能力的原因之一。

| 基本類型  | 大小    | 最小值    | 最大值         | 包裝器類型 |
|---------|---------|-----------|----------------|------------|
| `boolean` | 1-bit   | –         | –              | `Boolean`    |
| `char`    | 16-bit  | Unicode 0 | Unicode 216- 1 | `Character`  |
| `byte`    | 8-bit   | -128      | +127           | `Byte`[11]   |
| `short`   | 16-bit  | -215      | +215 – 1       | `Short`1     |
| `int`     | 32-bit  | -231      | +231 – 1       | `Integer`    |
| `long`    | 64-bit  | -263      | +263 – 1       | `Long`       |
| `float`   | 32-bit  | IEEE754   | IEEE754        | `Float`      |
| `double`  | 64-bit  | IEEE754   | IEEE754        | `Double`     |
| `void`    | –       | –         | –              | `Void`1      |


①：到Java 1.1才有，1.0版沒有。

數值類型全都是有符號（正負號）的，所以不必費勁尋找沒有符號的類型。
主數據類型也擁有自己的“包裝器”（wrapper）類。這意味著假如想讓堆內一個非主要對象表示那個基本類型，就要使用對應的包裝器。例如：

```
char c = 'x';
Character C = new Character('c');
```

也可以直接使用：

```
Character C = new Character('x');
```

這樣做的原因將在以後的章節裡解釋。

**1. 高精度數字**

Java 1.1增加了兩個類，用於進行高精度的計算：`BigInteger`和`BigDecimal`。儘管它們大致可以劃分為“包裝器”類型，但兩者都沒有對應的“基本類型”。

這兩個類都有自己特殊的“方法”，對應於我們針對基本類型執行的操作。也就是說，能對`int`或`float`做的事情，對`BigInteger`和`BigDecimal`一樣可以做。只是必須使用方法調用，不能使用運算符。此外，由於牽涉更多，所以運算速度會慢一些。我們犧牲了速度，但換來了精度。

`BigInteger`支持任意精度的整數。也就是說，我們可精確表示任意大小的整數值，同時在運算過程中不會丟失任何信息。
`BigDecimal`支持任意精度的定點數字。例如，可用它進行精確的幣值計算。

至於調用這兩個類時可選用的構造器和方法，請自行參考聯機幫助文檔。

## 2.2.3 Java的數組

幾乎所有程序設計語言都支持數組。在C和C++裡使用數組是非常危險的，因為那些數組只是內存塊。若程序訪問自己內存塊以外的數組，或者在初始化之前使用內存（屬於常規編程錯誤），會產生不可預測的後果（註釋②）。

②：在C++裡，應儘量不要使用數組，換用標準模板庫（Standard TemplateLibrary）裡更安全的容器。

Java的一項主要設計目標就是安全性。所以在C和C++裡困擾程序員的許多問題都未在Java裡重複。一個Java可以保證被初始化，而且不可在它的範圍之外訪問。由於系統自動進行範圍檢查，所以必然要付出一些代價：針對每個數組，以及在運行期間對索引的校驗，都會造成少量的內存開銷。但由此換回的是更高的安全性，以及更高的工作效率。為此付出少許代價是值得的。

創建對象數組時，實際創建的是一個引用數組。而且每個引用都會自動初始化成一個特殊值，並帶有自己的關鍵字：`null`（空）。一旦Java看到`null`，就知道該引用並未指向一個對象。正式使用前，必須為每個引用都分配一個對象。若試圖使用依然為null的一個引用，就會在運行期報告問題。因此，典型的數組錯誤在Java裡就得到了避免。

也可以創建基本類型數組。同樣地，編譯器能夠擔保對它的初始化，因為會將那個數組的內存劃分成零。

數組問題將在以後的章節裡詳細討論。
