# 10.8 壓縮

Java 1.1也添加一個類，用以支持對壓縮格式的數據流的讀寫。它們封裝到現成的IO類中，以提供壓縮功能。

此時Java 1.1的一個問題顯得非常突出：它們不是從新的`Reader`和`Writer`類派生出來的，而是屬於`InputStream`和`OutputStream`層次結構的一部分。所以有時不得不混合使用兩種類型的數據流（注意可用`InputStreamReader`和`OutputStreamWriter`在不同的類型間方便地進行轉換）。

| Java 1.1壓縮類 | 功能 |
| --- | --- |
| `CheckedInputStream` | `GetCheckSum()`爲任何`InputStream`產生校驗和（不僅是解壓） |
| `CheckedOutputStream` | `GetCheckSum()`爲任何`OutputStream`產生校驗和（不僅是解壓） |
| `DeflaterOutputStream` | 用於壓縮類的基類 |
| `ZipOutputStream` | 一個`DeflaterOutputStream`，將數據壓縮成Zip文件格式 |
| `GZIPOutputStream` | 一個`DeflaterOutputStream`，將數據壓縮成GZIP文件格式 |
| `InflaterInputStream` | 用於解壓類的基類 |
| `ZipInputStream` | 一個`DeflaterInputStream`，解壓用Zip文件格式保存的數據 |
| `GZIPInputStream` | 一個`DeflaterInputStream`，解壓用GZIP文件格式保存的數據 |

儘管存在許多種壓縮算法，但是Zip和GZIP可能最常用的。所以能夠很方便地用多種現成的工具來讀寫這些格式的壓縮數據。

## 10.8.1 用GZIP進行簡單壓縮

GZIP接口非常簡單，所以如果只有單個數據流需要壓縮（而不是一系列不同的數據），那麼它就可能是最適當選擇。下面是對單個文件進行壓縮的例子：

```
//: GZIPcompress.java
// Uses Java 1.1 GZIP compression to compress
// a file whose name is passed on the command
// line.
import java.io.*;
import java.util.zip.*;

public class GZIPcompress {
  public static void main(String[] args) {
    try {
      BufferedReader in =
        new BufferedReader(
          new FileReader(args[0]));
      BufferedOutputStream out =
        new BufferedOutputStream(
          new GZIPOutputStream(
            new FileOutputStream("test.gz")));
      System.out.println("Writing file");
      int c;
      while((c = in.read()) != -1)
        out.write(c);
      in.close();
      out.close();
      System.out.println("Reading file");
      BufferedReader in2 =
        new BufferedReader(
          new InputStreamReader(
            new GZIPInputStream(
              new FileInputStream("test.gz"))));
      String s;
      while((s = in2.readLine()) != null)
        System.out.println(s);
    } catch(Exception e) {
      e.printStackTrace();
    }
  }
} ///:~
```

壓縮類的用法非常直觀——只需將輸出流封裝到一個`GZIPOutputStream`或者`ZipOutputStream`內，並將輸入流封裝到`GZIPInputStream`或者`ZipInputStream`內即可。剩餘的全部操作就是標準的IO讀寫。然而，這是一個很典型的例子，我們不得不混合使用新舊IO流：數據的輸入使用`Reader`類，而`GZIPOutputStream`的構造器只能接收一個`OutputStream`對象，不能接收`Writer`對象。

## 10.8.2 用Zip進行多文件保存

提供了Zip支持的Java 1.1庫顯得更加全面。利用它可以方便地保存多個文件。甚至有一個獨立的類來簡化對Zip文件的讀操作。這個庫采采用的是標準Zip格式，所以能與當前因特網上使用的大量壓縮、解壓工具很好地協作。下面這個例子採取了與前例相同的形式，但能根據我們需要控制任意數量的命令行參數。除此之外，它展示瞭如何用`Checksum`類來計算和校驗文件的“校驗和”（`Checksum`）。可選用兩種類型的`Checksum`：`Adler32`（速度要快一些）和`CRC32`（慢一些，但更準確）。

```
//: ZipCompress.java
// Uses Java 1.1 Zip compression to compress
// any number of files whose names are passed
// on the command line.
import java.io.*;
import java.util.*;
import java.util.zip.*;

public class ZipCompress {
  public static void main(String[] args) {
    try {
      FileOutputStream f =
        new FileOutputStream("test.zip");
      CheckedOutputStream csum =
        new CheckedOutputStream(
          f, new Adler32());
      ZipOutputStream out =
        new ZipOutputStream(
          new BufferedOutputStream(csum));
      out.setComment("A test of Java Zipping");
      // Can't read the above comment, though
      for(int i = 0; i < args.length; i++) {
        System.out.println(
          "Writing file " + args[i]);
        BufferedReader in =
          new BufferedReader(
            new FileReader(args[i]));
        out.putNextEntry(new ZipEntry(args[i]));
        int c;
        while((c = in.read()) != -1)
          out.write(c);
        in.close();
      }
      out.close();
      // Checksum valid only after the file
      // has been closed!
      System.out.println("Checksum: " +
        csum.getChecksum().getValue());
      // Now extract the files:
      System.out.println("Reading file");
      FileInputStream fi =
         new FileInputStream("test.zip");
      CheckedInputStream csumi =
        new CheckedInputStream(
          fi, new Adler32());
      ZipInputStream in2 =
        new ZipInputStream(
          new BufferedInputStream(csumi));
      ZipEntry ze;
      System.out.println("Checksum: " +
        csumi.getChecksum().getValue());
      while((ze = in2.getNextEntry()) != null) {
        System.out.println("Reading file " + ze);
        int x;
        while((x = in2.read()) != -1)
          System.out.write(x);
      }
      in2.close();
      // Alternative way to open and read
      // zip files:
      ZipFile zf = new ZipFile("test.zip");
      Enumeration e = zf.entries();
      while(e.hasMoreElements()) {
        ZipEntry ze2 = (ZipEntry)e.nextElement();
        System.out.println("File: " + ze2);
        // ... and extract the data as before
      }
    } catch(Exception e) {
      e.printStackTrace();
    }
  }
} ///:~
```

對於要加入壓縮檔的每一個文件，都必須調用`putNextEntry()`，並將其傳遞給一個`ZipEntry`對象。`ZipEntry`對象包含了一個功能全面的接口，利用它可以獲取和設置Zip文件內那個特定的`Entry`（入口）上能夠接受的所有數據：名字、壓縮後和壓縮前的長度、日期、CRC校驗和、額外字段的數據、註釋、壓縮方法以及它是否一個目錄入口等等。然而，雖然Zip格式提供了設置密碼的方法，但Java的Zip庫沒有提供這方面的支持。而且儘管`CheckedInputStream`和`CheckedOutputStream`同時提供了對`Adler32`和`CRC32`校驗和的支持，但是`ZipEntry`只支持CRC的接口。這雖然屬於基層Zip格式的限制，但卻限制了我們使用速度更快的`Adler32`。

爲解壓文件，`ZipInputStream`提供了一個`getNextEntry()`方法，能在有的前提下返回下一個`ZipEntry`。作爲一個更簡潔的方法，可以用`ZipFile`對象讀取文件。該對象有一個`entries()`方法，可以爲`ZipEntry`返回一個`Enumeration`（枚舉）。

爲讀取校驗和，必須多少擁有對關聯的`Checksum`對象的訪問權限。在這裏保留了指向`CheckedOutputStream`和`CheckedInputStream`對象的一個引用。但是，也可以只佔有指向`Checksum`對象的一個引用。

Zip流中一個令人困惑的方法是`setComment()`。正如前面展示的那樣，我們可在寫一個文件時設置註釋內容，但卻沒有辦法取出`ZipInputStream`內的註釋。看起來，似乎只能通過`ZipEntry`逐個入口地提供對註釋的完全支持。

當然，使用GZIP或Zip庫時並不僅僅限於文件——可以壓縮任何東西，包括要通過網絡連接發送的數據。

## 10.8.3 Java歸檔（`jar`）實用程序

Zip格式亦在Java 1.1的JAR（Java ARchive）文件格式中得到了採用。這種文件格式的作用是將一系列文件合併到單個壓縮文件裏，就象Zip那樣。然而，同Java中其他任何東西一樣，JAR文件是跨平臺的，所以不必關心涉及具體平臺的問題。除了可以包括聲音和圖像文件以外，也可以在其中包括類文件。

涉及因特網應用時，JAR文件顯得特別有用。在JAR文件之前，Web瀏覽器必須重複多次請求Web服務器，以便下載完構成一個“程序片”（Applet）的所有文件。除此以外，每個文件都是未經壓縮的。但在將所有這些文件合併到一個JAR文件裏以後，只需向遠程服務器發出一次請求即可。同時，由於採用了壓縮技術，所以可在更短的時間裏獲得全部數據。另外，JAR文件裏的每個入口（條目）都可以加上數字化簽名（詳情參考Java用戶文檔）。

一個JAR文件由一系列採用Zip壓縮格式的文件構成，同時還有一張“詳情單”，對所有這些文件進行了描述（可創建自己的詳情單文件；否則，`jar`程序會爲我們代勞）。在聯機用戶文檔中，可以找到與JAR詳情單更多的資料（詳情單的英語是“Manifest”）。
`jar`實用程序已與Sun的JDK配套提供，可以按我們的選擇自動壓縮文件。請在命令行調用它：

```
jar [選項] 說明 [詳情單] 輸入文件
```

其中，“選項”用一系列字母表示（不必輸入連字號或其他任何指示符）。如下所示：

```
c 創建新的或空的壓縮檔
t 列出目錄表
x 解壓所有文件
x file 解壓指定文件
f 指出“我準備向你提供文件名”。若省略此參數，jar會假定它的輸入來自標準輸入；或者在它創建文件時，輸出會進入標準輸出內
m 指出第一個參數將是用戶自建的詳情表文件的名字
v 產生詳細輸出，對jar做的工作進行鉅細無遺的描述
O 只保存文件；不壓縮文件（用於創建一個JAR文件，以便我們將其置入自己的類路徑中）
M 不自動生成詳情表文件
```

在準備進入JAR文件的文件中，若包括了一個子目錄，那個子目錄會自動添加，其中包括它自己的所有子目錄，以此類推。路徑信息也會得到保留。

下面是調用`jar`的一些典型方法：

```
jar cf myJarFile.jar *.class
```

用於創建一個名爲`myJarFile.jar`的JAR文件，其中包含了當前目錄中的所有類文件，同時還有自動產生的詳情表文件。

```
jar cmf myJarFile.jar myManifestFile.mf *.class
```

與前例類似，但添加了一個名爲`myManifestFile.mf`的用戶自建詳情表文件。

```
jar tf myJarFile.jar
```

生成`myJarFile.jar`內所有文件的一個目錄表。

```
jar tvf myJarFile.jar
```

添加`verbose`（詳盡）標誌，提供與`myJarFile.jar`中的文件有關的、更詳細的資料。

```
jar cvf myApp.jar audio classes image
```

假定`audio`，`classes`和`image`是子目錄，這樣便將所有子目錄合併到文件`myApp.jar`中。其中也包括了`verbose`標誌，可在`jar`程序工作時反饋更詳盡的信息。

如果用O選項創建了一個JAR文件，那個文件就可置入自己的類路徑（`CLASSPATH`）中：

```
CLASSPATH="lib1.jar;lib2.jar;"
```

Java能在`lib1.jar`和`lib2.jar`中搜索目標類文件。

`jar`工具的功能沒有`zip`工具那麼豐富。例如，不能夠添加或更新一個現成JAR文件中的文件，只能從頭開始新建一個JAR文件。此外，不能將文件移入一個JAR文件，並在移動後將它們刪除。然而，在一種平臺上創建的JAR文件可在其他任何平臺上由`jar`工具毫無阻礙地讀出（這個問題有時會困擾`zip`工具）。

正如大家在第13章會看到的那樣，我們也用JAR爲Java Beans打包。
