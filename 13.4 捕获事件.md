# 13.4 捕獲事件

大家可注意到假如編譯和運行上面的程序片，按下按鈕後不會發生任何事情。必須進入程序片內部，編寫用於決定要發生什麼事情的代碼。對於由事件驅動的程序設計，它的基本目標就是用代碼捕獲發生的事件，並由代碼對那些事件作出響應。事實上，GUI的大部分內容都是圍繞這種事件驅動的程序設計展開的。

經過本書前面的學習，大家應該有了面向對象程序設計的一些基礎，此時可能會想到應當有一些面向對象的方法來專門控制事件。例如，也許不得不繼承每個按鈕，並重載一些“按鈕按下”方法（儘管這顯得非常麻煩有有限）。大家也可能認為存在一些主控“事件”類，其中為希望響應的每個事件都包含了一個方法。

在對象以前，事件控制的典型方式是`switch`語句。每個事件都對應一個獨一無二的整數編號；而且在主事件控制方法中，需要專門為那個值寫一個`switch`。

Java 1.0的AWT沒有采用任何面向對象的手段。此外，它也沒有使用`switch`語句，沒有打算依靠那些分配給事件的數字。相反，我們必須創建`if`語句的一個嵌套系列。通過if語句，我們需要嘗試做的事情是偵測到作為事件“目標”的對象。換言之，那是我們關心的全部內容——假如某個按鈕是一個事件的目標，那麼它肯定是一次鼠標點擊，並要基於那個假設繼續下去。但是，事件裡也可能包含了其他信息。例如，假如想調查一次鼠標點擊的像素位置，以便畫一條引向那個位置的線，那麼`Event`對象裡就會包含那個位置的信息（也要注意Java 1.0的組件只能產生有限種類的事件，而Java 1.1和Swing/JFC組件則可產生完整的一系列事件）。

Java 1.0版的AWT方法串聯的條件語句中存在`action()`方法的調用。雖然整個Java 1.0版的事件模型不兼容Java 1.1版，但它在還不支持Java1.1版的機器和運行簡單的程序片的系統中更廣泛地使用，忠告您使用它會變得非常的舒適，包括對下面使用的`action()`程序方法而言。

`action()`擁有兩個參數：第一個是事件的類型，包括所有的觸發調用`action()`的事件的有關信息。例如鼠標單擊、普通按鍵按下或釋放、特殊按鍵按下或釋放、鼠標移動或者拖動、事件組件得到或丟失焦點，等等。第二個參數通常是我們忽略的事件目標。第二個參數封裝在事件目標中，所以它像一個參數一樣的冗長。

需調用`action()`時情況非常有限：將控件置入窗體時，一些類型的控件（按鈕、複選框、下拉列表單、菜單）會發生一種“標準行動”，從而隨相應的`Event`對象發起對`action()`的調用。比如對按鈕來說，一旦按鈕被按下，而且沒有再多按一次，就會調用它的`action()`方法。這種行為通常正是我們所希望的，因為這正是我們對一個按鈕正常觀感。但正如本章後面要講到的那樣，還可通過`handleEvent()`方法來處理其他許多類型的事件。

前面的例程可進行一些擴展，以便象下面這樣控制按鈕的點擊：

```
//: Button2.java
// Capturing button presses
import java.awt.*;
import java.applet.*;

public class Button2 extends Applet {
  Button
    b1 = new Button("Button 1"),
    b2 = new Button("Button 2");
  public void init() {
    add(b1);
    add(b2);
  }
  public boolean action(Event evt, Object arg) {
    if(evt.target.equals(b1))
      getAppletContext().showStatus("Button 1");
    else if(evt.target.equals(b2))
      getAppletContext().showStatus("Button 2");
    // Let the base class handle it:
    else
      return super.action(evt, arg);
    return true; // We've handled it here
  }
} ///:~
```

為了解目標是什麼，需要向`Event`對象詢問它的`target`（目標）成員是什麼，然後用`equals()`方法檢查它是否與自己感興趣的目標對象引用相符。為所有感興趣的對象寫好引用後，必須在末尾的`else`語句中調用`super.action(evt, arg)`方法。我們在第7章已經說過（有關多態性的那一章），此時調用的是我們重載過的方法，而非它的基類版本。然而，基類版本也針對我們不感興趣的所有情況提供了相應的控制代碼。除非明確進行，否則它們是不會得到調用的。返回值指出我們是否已經處理了它，所以假如確實與一個事件相符，就應返回`true`；否則就返回由基類`event()`返回的東西。

對這個例子來說，最簡單的行動就是打印出到底是什麼按鈕被按下。一些系統允許你彈出一個小消息窗口，但Java程序片卻防礙窗口的彈出。不過我們可以用調用`Applet`方法的`getAppletContext()`來訪問瀏覽器，然後用`showStatus()`在瀏覽器窗口底部的狀態欄上顯示一條信息（註釋③）。還可用同樣的方法打印出對事件的一段完整說明文字，方法是調用`getAppletConext().showStatus(evt + "")`。空字符串會強制編譯器將`evt`轉換成一個字符串。這些報告對於測試和調試特別有用，因為瀏覽器可能會覆蓋我們的消息。

③：`ShowStatus()`也屬於`Applet`的一個方法，所以可直接調用它，不必調用`getAppletContext()`。

儘管看起來似乎很奇怪，但我們確實也能通過`event()`中的第二個參數將一個事件與按鈕上的文字相配。採用這種方法，上面的例子就變成了：

```
//: Button3.java
// Matching events on button text
import java.awt.*;
import java.applet.*;

public class Button3 extends Applet {
  Button
    b1 = new Button("Button 1"),
    b2 = new Button("Button 2");
  public void init() {
    add(b1);
    add(b2);
  }
  public boolean action (Event evt, Object arg) {
    if(arg.equals("Button 1"))
      getAppletContext().showStatus("Button 1");
    else if(arg.equals("Button 2"))
      getAppletContext().showStatus("Button 2");
    // Let the base class handle it:
    else
      return super.action(evt, arg);
    return true; // We've handled it here
  }
} ///:~
```

很難確切知道`equals()`方法在這兒要做什麼。這種方法有一個很大的問題，就是開始使用這個新技術的Java程序員至少需要花費一個受挫折的時期來在比較按鈕上的文字時發現他們要麼大寫了要麼寫錯了（我就有這種經驗）。同樣，如果我們改變了按鈕上的文字，程序代碼將不再工作（但我們不會得到任何編譯時和運行時的信息）。所以如果可能，我們就得避免使用這種方法。
