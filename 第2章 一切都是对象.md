# 第2章 一切都是对象


“尽管以C++为基础，但Java是一种更纯粹的面向对象程序设计语言”。

无论C++还是Java都属于杂合语言。但在Java中，设计者觉得这种杂合并不象在C++里那么重要。杂合语言允许采用多种编程风格；之所以说C++是一种杂合语言，是因为它支持与C语言的向后兼容能力。由于C++是C的一个超集，所以包含的许多特性都是后者不具备的，这些特性使C++在某些地方显得过于复杂。

Java语言首先便假定了我们只希望进行面向对象的程序设计。也就是说，正式用它设计之前，必须先将自己的思想转入一个面向对象的世界（除非早已习惯了这个世界的思维方式）。只有做好这个准备工作，与其他OOP语言相比，才能体会到Java的易学易用。在本章，我们将探讨Java程序的基本组件，并体会为什么说Java乃至Java程序内的一切都是对象。



# 2.1 用引用操縱對象

每種編程語言都有自己的數據處理方式。有些時候，程序員必須時刻留意準備處理的是什麼類型。您曾利用一些特殊語法直接操作過對象，或處理過一些間接表示的對象嗎（C或C++裡的指針）？

所有這些在Java裡都得到了簡化，任何東西都可看作對象。因此，我們可採用一種統一的語法，任何地方均可照搬不誤。但要注意，儘管將一切都“看作”對象，但操縱的標識符實際是指向一個對象的“句柄”（Handle）。在其他Java參考書裡，還可看到有的人將其稱作一個“引用”，甚至一個“指針”。可將這一情形想象成用遙控板（引用）操縱電視機（對象）。只要握住這個遙控板，就相當於掌握了與電視機連接的通道。但一旦需要“換頻道”或者“關小聲音”，我們實際操縱的是遙控板（引用），再由遙控板自己操縱電視機（對象）。如果要在房間裡四處走走，並想保持對電視機的控制，那麼手上拿著的是遙控板，而非電視機。

此外，即使沒有電視機，遙控板亦可獨立存在。也就是說，只是由於擁有一個引用，並不表示必須有一個對象同它連接。所以如果想容納一個詞或句子，可創建一個`String`引用：

```
String s;
```

但這裡創建的只是引用，並不是對象。若此時向`s`發送一條消息，就會獲得一個錯誤（運行期）。這是由於`s`實際並未與任何東西連接（即“沒有電視機”）。因此，一種更安全的做法是：創建一個引用時，記住無論如何都進行初始化：

```
String s = "asdf";
```

然而，這裡採用的是一種特殊類型：字符串可用加引號的文字初始化。通常，必須為對象使用一種更通用的初始化類型。


# 2.2 所有對象都必須創建


創建引用時，我們希望它同一個新對象連接。通常用`new`關鍵字達到這一目的。`new`的意思是：“把我變成這些對象的一種新類型”。所以在上面的例子中，可以說：

```
String s = new String("asdf");
```

它不僅指出“將我變成一個新字符串”，也通過提供一個初始字符串，指出了“如何生成這個新字符串”。

當然，字符串（`String`）並非唯一的類型。Java配套提供了數量眾多的現成類型。對我們來講，最重要的就是記住能自行創建類型。事實上，這應是Java程序設計的一項基本操作，是繼續本書後餘部分學習的基礎。

## 2.2.1 保存到什麼地方

程序運行時，我們最好對數據保存到什麼地方做到心中有數。特別要注意的是內存的分配。有六個地方都可以保存數據：

(1) 寄存器。這是最快的保存區域，因為它位於和其他所有保存方式不同的地方：處理器內部。然而，寄存器的數量十分有限，所以寄存器是根據需要由編譯器分配。我們對此沒有直接的控制權，也不可能在自己的程序裡找到寄存器存在的任何蹤跡。

(2) 棧。駐留於常規RAM（隨機訪問存儲器）區域，但可通過它的“棧指針”獲得處理的直接支持。棧指針若向下移，會創建新的內存；若向上移，則會釋放那些內存。這是一種特別快、特別有效的數據保存方式，僅次於寄存器。創建程序時，Java編譯器必須準確地知道棧內保存的所有數據的“長度”以及“存在時間”。這是由於它必須生成相應的代碼，以便向上和向下移動指針。這一限制無疑影響了程序的靈活性，所以儘管有些Java數據要保存在棧裡——特別是對象引用，但Java對象並不放到其中。

(3) 堆。一種常規用途的內存池（也在RAM區域），其中保存了Java對象。和棧不同，“內存堆”或“堆”（Heap）最吸引人的地方在於編譯器不必知道要從堆裡分配多少存儲空間，也不必知道存儲的數據要在堆裡停留多長的時間。因此，用堆保存數據時會得到更大的靈活性。要求創建一個對象時，只需用new命令編制相關的代碼即可。執行這些代碼時，會在堆裡自動進行數據的保存。當然，為達到這種靈活性，必然會付出一定的代價：在堆裡分配存儲空間時會花掉更長的時間！

(4) 靜態存儲。這兒的“靜態”（`Static`）是指“位於固定位置”（儘管也在RAM裡）。程序運行期間，靜態存儲的數據將隨時等候調用。可用`static`關鍵字指出一個對象的特定元素是靜態的。但Java對象本身永遠都不會置入靜態存儲空間。

(5) 常數存儲。常數值通常直接置於程序代碼內部。這樣做是安全的，因為它們永遠都不會改變。有的常數需要嚴格地保護，所以可考慮將它們置入只讀存儲器（ROM）。

(6) 非RAM存儲。若數據完全獨立於一個程序之外，則程序不運行時仍可存在，並在程序的控制範圍之外。其中兩個最主要的例子便是“流式對象”和“固定對象”。對於流式對象，對象會變成字節流，通常會發給另一臺機器。而對於固定對象，對象保存在磁盤中。即使程序中止運行，它們仍可保持自己的狀態不變。對於這些類型的數據存儲，一個特別有用的技巧就是它們能存在於其他媒體中。一旦需要，甚至能將它們恢復成普通的、基於RAM的對象。Java 1.1提供了對Lightweight persistence的支持。未來的版本甚至可能提供更完整的方案。

## 2.2.2 特殊情況：基本類型

有一系列類需特別對待；可將它們想象成“基本”、“主要”或者“主”（Primitive）類型，進行程序設計時要頻繁用到它們。之所以要特別對待，是由於用`new`創建對象（特別是小的、簡單的變量）並不是非常有效，因為`new`將對象置於“堆”裡。對於這些類型，Java採納了與C和C++相同的方法。也就是說，不是用`new`創建變量，而是創建一個並非引用的“自動”變量。這個變量容納了具體的值，並置於棧中，能夠更高效地存取。

Java決定了每種主要類型的大小。就象在大多數語言裡那樣，這些大小並不隨著機器結構的變化而變化。這種大小的不可更改正是Java程序具有很強移植能力的原因之一。

| 基本類型  | 大小    | 最小值    | 最大值         | 包裝器類型 |
|---------|---------|-----------|----------------|------------|
| `boolean` | 1-bit   | –         | –              | `Boolean`    |
| `char`    | 16-bit  | Unicode 0 | Unicode 216- 1 | `Character`  |
| `byte`    | 8-bit   | -128      | +127           | `Byte`[11]   |
| `short`   | 16-bit  | -215      | +215 – 1       | `Short`1     |
| `int`     | 32-bit  | -231      | +231 – 1       | `Integer`    |
| `long`    | 64-bit  | -263      | +263 – 1       | `Long`       |
| `float`   | 32-bit  | IEEE754   | IEEE754        | `Float`      |
| `double`  | 64-bit  | IEEE754   | IEEE754        | `Double`     |
| `void`    | –       | –         | –              | `Void`1      |


①：到Java 1.1才有，1.0版沒有。

數值類型全都是有符號（正負號）的，所以不必費勁尋找沒有符號的類型。
主數據類型也擁有自己的“包裝器”（wrapper）類。這意味著假如想讓堆內一個非主要對象表示那個基本類型，就要使用對應的包裝器。例如：

```
char c = 'x';
Character C = new Character('c');
```

也可以直接使用：

```
Character C = new Character('x');
```

這樣做的原因將在以後的章節裡解釋。

**1. 高精度數字**

Java 1.1增加了兩個類，用於進行高精度的計算：`BigInteger`和`BigDecimal`。儘管它們大致可以劃分為“包裝器”類型，但兩者都沒有對應的“基本類型”。

這兩個類都有自己特殊的“方法”，對應於我們針對基本類型執行的操作。也就是說，能對`int`或`float`做的事情，對`BigInteger`和`BigDecimal`一樣可以做。只是必須使用方法調用，不能使用運算符。此外，由於牽涉更多，所以運算速度會慢一些。我們犧牲了速度，但換來了精度。

`BigInteger`支持任意精度的整數。也就是說，我們可精確表示任意大小的整數值，同時在運算過程中不會丟失任何信息。
`BigDecimal`支持任意精度的定點數字。例如，可用它進行精確的幣值計算。

至於調用這兩個類時可選用的構造器和方法，請自行參考聯機幫助文檔。

## 2.2.3 Java的數組

幾乎所有程序設計語言都支持數組。在C和C++裡使用數組是非常危險的，因為那些數組只是內存塊。若程序訪問自己內存塊以外的數組，或者在初始化之前使用內存（屬於常規編程錯誤），會產生不可預測的後果（註釋②）。

②：在C++裡，應儘量不要使用數組，換用標準模板庫（Standard TemplateLibrary）裡更安全的容器。

Java的一項主要設計目標就是安全性。所以在C和C++裡困擾程序員的許多問題都未在Java裡重複。一個Java可以保證被初始化，而且不可在它的範圍之外訪問。由於系統自動進行範圍檢查，所以必然要付出一些代價：針對每個數組，以及在運行期間對索引的校驗，都會造成少量的內存開銷。但由此換回的是更高的安全性，以及更高的工作效率。為此付出少許代價是值得的。

創建對象數組時，實際創建的是一個引用數組。而且每個引用都會自動初始化成一個特殊值，並帶有自己的關鍵字：`null`（空）。一旦Java看到`null`，就知道該引用並未指向一個對象。正式使用前，必須為每個引用都分配一個對象。若試圖使用依然為null的一個引用，就會在運行期報告問題。因此，典型的數組錯誤在Java裡就得到了避免。

也可以創建基本類型數組。同樣地，編譯器能夠擔保對它的初始化，因為會將那個數組的內存劃分成零。

數組問題將在以後的章節裡詳細討論。


# 2.3 絕對不要清除對象


在大多數程序設計語言中，變量的“存在時間”（Lifetime）一直是程序員需要著重考慮的問題。變量應持續多長的時間？如果想清除它，那麼何時進行？在變量存在時間上糾纏不清會造成大量的程序錯誤。在下面的小節裡，將闡示Java如何幫助我們完成所有清除工作，從而極大了簡化了這個問題。

## 2.3.1 作用域

大多數程序設計語言都提供了“作用域”（Scope）的概念。對於在作用域裡定義的名字，作用域同時決定了它的“可見性”以及“存在時間”。在C，C++和Java裡，作用域是由花括號的位置決定的。參考下面這個例子：

```
{
  int x = 12;
  /* only x available */
  {
    int q = 96;
    /* both x & q available */
  }
  /* only x available */
  /* q “out of scope” */
}
```

作為在作用域裡定義的一個變量，它只有在那個作用域結束之前才可使用。

在上面的例子中，縮進排版使Java代碼更易辨讀。由於Java是一種形式自由的語言，所以額外的空格、製表位以及回車都不會對結果程序造成影響。

注意儘管在C和C++裡是合法的，但在Java裡不能象下面這樣書寫代碼：

```
{
  int x = 12;
  {
    int x = 96; /* illegal */
  }
}
```

編譯器會認為變量`x`已被定義。所以C和C++能將一個變量“隱藏”在一個更大的作用域裡。但這種做法在Java裡是不允許的，因為Java的設計者認為這樣做使程序產生了混淆。

## 2.3.2 對象的作用域

Java對象不具備與基本類型一樣的存在時間。用`new`關鍵字創建一個Java對象的時候，它會超出作用域的範圍之外。所以假若使用下面這段代碼：

```
{
String s = new String("a string");
} /* 作用域的終點 */
```

那麼引用`s`會在作用域的終點處消失。然而，`s`指向的`String`對象依然佔據著內存空間。在上面這段代碼裡，我們沒有辦法訪問對象，因為指向它的唯一一個引用已超出了作用域的邊界。在後面的章節裡，大家還會繼續學習如何在程序運行期間傳遞和複製對象引用。

這樣造成的結果便是：對於用`new`創建的對象，只要我們願意，它們就會一直保留下去。這個編程問題在C和C++裡特別突出。看來在C++裡遇到的麻煩最大：由於不能從語言獲得任何幫助，所以在需要對象的時候，根本無法確定它們是否可用。而且更麻煩的是，在C++裡，一旦工作完成，必須保證將對象清除。

這樣便帶來了一個有趣的問題。假如Java讓對象依然故我，怎樣才能防止它們大量充斥內存，並最終造成程序的“凝固”呢。在C++裡，這個問題最令程序員頭痛。但Java以後，情況卻發生了改觀。Java有一個特別的“垃圾收集器”，它會查找用new創建的所有對象，並辨別其中哪些不再被引用。隨後，它會自動釋放由那些閒置對象佔據的內存，以便能由新對象使用。這意味著我們根本不必操心內存的回收問題。只需簡單地創建對象，一旦不再需要它們，它們就會自動離去。這樣做可防止在C++裡很常見的一個編程問題：由於程序員忘記釋放內存造成的“內存溢出”。


# 2.4 新建數據類型：類


(2)4 新建數據類型：類

如果說一切東西都是對象，那麼用什麼決定一個“類”（Class）的外觀與行為呢？換句話說，是什麼建立起了一個對象的“類型”（Type）呢？大家可能猜想有一個名為`type`的關鍵字。但從歷史看來，大多數面向對象的語言都用關鍵字`class`表達這樣一個意思：“我準備告訴你對象一種新類型的外觀”。`class`關鍵字太常用了，以至於本書許多地方並沒有用粗體字或雙引號加以強調。在這個關鍵字的後面，應該跟隨新數據類型的名稱。例如：

```
class ATypeName {/*類主體置於這裡}
```

這樣就引入了一種新類型，接下來便可用`new`創建這種類型的一個新對象：

```
ATypeName a = new ATypeName();
```

在`ATypeName`裡，類主體只由一條註釋構成（星號和斜槓以及其中的內容，本章後面還會詳細講述），所以並不能對它做太多的事情。事實上，除非為其定義了某些方法，否則根本不能指示它做任何事情。

## 2.4.1 字段和方法

定義一個類時（我們在Java裡的全部工作就是定義類、製作那些類的對象以及將消息發給那些對象），可在自己的類裡設置兩種類型的元素：數據成員（有時也叫“字段”）以及成員函數（通常叫“方法”）。其中，數據成員是一種對象（通過它的引用與其通信），可以為任何類型。它也可以是基本類型（並不是引用）之一。如果是指向對象的一個引用，則必須初始化那個引用，用一種名為“構造器”（第4章會對此詳述）的特殊函數將其與一個實際對象連接起來（就象早先看到的那樣，使用`new`關鍵字）。但若是一種基本類型，則可在類定義位置直接初始化（正如後面會看到的那樣，引用亦可在定義位置初始化）。

每個對象都為自己的數據成員保有存儲空間；數據成員不會在對象之間共享。下面是定義了一些數據成員的類示例：

```
class DataOnly {
  int i;
  float f;
  boolean b;
}
```

這個類並沒有做任何實質性的事情，但我們可創建一個對象：

```
DataOnly d = new DataOnly();
```

可將值賦給數據成員，但首先必須知道如何引用一個對象的成員。為達到引用對象成員的目的，首先要寫上對象引用的名字，再跟隨一個點號（句點），再跟隨對象內部成員的名字。即“對象引用.成員”。例如：

```
d.i = 47;
d.f = 1.1f;
d.b = false;
```

一個對象也可能包含了另一個對象，而另一個對象裡則包含了我們想修改的數據。對於這個問題，只需保持“連接句點”即可。例如：

```
myPlane.leftTank.capacity = 100;
```

除容納數據之外，`DataOnly`類再也不能做更多的事情，因為它沒有成員函數（方法）。為正確理解工作原理，首先必須知道“參數”和“返回值”的概念。我們馬上就會詳加解釋。

**1. 基本類型的成員的默認值**

若某個類成員屬於基本類型，那麼即使不明確（顯式）進行初始化，也可以保證它們獲得一個默認值。

基本類型 默認值

```
Boolean false
Char '\u0000'(null)
byte (byte)0
short (short)0
int 0
long 0L
float 0.0f
double 0.0d
```

一旦將變量作為類成員使用，就要特別注意由Java分配的默認值。這樣做可保證基本類型的成員變量肯定得到了初始化（C++不具備這一功能），可有效遏止多種相關的編程錯誤。

然而，這種保證卻並不適用於“局部”變量——那些變量並非一個類的字段。所以，假若在一個函數定義中寫入下述代碼：

```
int x;
```

那麼`x`會得到一些隨機值（這與C和C++是一樣的），不會自動初始化成零。我們責任是在正式使用x前分配一個適當的值。如果忘記，就會得到一條編譯期錯誤，告訴我們變量可能尚未初始化。這種處理正是Java優於C++的表現之一。許多C++編譯器會對變量未初始化發出警告，但在Java裡卻是錯誤。


# 2.5 方法、參數和返回值


迄今為止，我們一直用“函數”（Function）這個詞指代一個已命名的子例程。但在Java裡，更常用的一個詞卻是“方法”（Method），代表“完成某事的途徑”。儘管它們表達的實際是同一個意思，但從現在開始，本書將一直使用“方法”，而不是“函數”。

Java的“方法”決定了一個對象能夠接收的消息。通過本節的學習，大家會知道方法的定義有多麼簡單！

方法的基本組成部分包括名字、參數、返回類型以及主體。下面便是它最基本的形式：

```
返回類型 方法名( /* 參數列表*/ ) {/* 方法主體 */}
```

返回類型是指調用方法之後返回的數值類型。顯然，方法名的作用是對具體的方法進行標識和引用。參數列表列出了想傳遞給方法的信息類型和名稱。

Java的方法只能作為類的一部分創建。只能針對某個對象調用一個方法（註釋③），而且那個對象必須能夠執行那個方法調用。若試圖為一個對象調用錯誤的方法，就會在編譯期得到一條出錯消息。為一個對象調用方法時，需要先列出對象的名字，在後面跟上一個句點，再跟上方法名以及它的參數列表。亦即`對象名.方法名(參數1，參數2，參數3...)`。舉個例子來說，假設我們有一個方法名叫`f()`，它沒有參數，返回的是類型為`int`的一個值。那麼，假設有一個名為`a`的對象，可為其調用方法`f()`，則代碼如下：

```
int x = a.f();
```

返回值的類型必須兼容x的類型。

象這樣調用一個方法的行動通常叫作“向對象發送一條消息”。在上面的例子中，消息是`f()`，而對象是`a`。面向對象的程序設計通常簡單地歸納為“向對象發送消息”。

③：正如馬上就要學到的那樣，“靜態”方法可針對類調用，毋需一個對象。

## 2.5.1 參數列表

參數列表規定了我們傳送給方法的是什麼信息。正如大家或許已猜到的那樣，這些信息——如同Java內其他任何東西——採用的都是對象的形式。因此，我們必須在參數列表裡指定要傳遞的對象類型，以及每個對象的名字。正如在Java其他地方處理對象時一樣，我們實際傳遞的是“引用”（註釋④）。然而，引用的類型必須正確。倘若希望參數是一個“字符串”，那麼傳遞的必須是一個字符串。

④：對於前面提及的“特殊”數據類型`boolean`，`char`，`byte`，`short`，`int`，`long`，，`float`以及`double`來說是一個例外。但在傳遞對象時，通常都是指傳遞指向對象的引用。

下面讓我們考慮將一個字符串作為參數使用的方法。下面列出的是定義代碼，必須將它置於一個類定義裡，否則無法編譯：

```
int storage(String s) {
return s.length() * 2;
}
```

這個方法告訴我們需要多少字節才能容納一個特定字符串裡的信息（字符串裡的每個字符都是16位，或者說2個字節、長整數，以便提供對Unicode字符的支持）。參數的類型為`String`，而且叫作`s`。一旦將`s`傳遞給方法，就可將它當作其他對象一樣處理（可向其發送消息）。在這裡，我們調用的是`length()`方法，它是`String`的方法之一。該方法返回的是一個字符串裡的字符數。

通過上面的例子，也可以瞭解`return`關鍵字的運用。它主要做兩件事情。首先，它意味著“離開方法，我已完工了”。其次，假設方法生成了一個值，則那個值緊接在`return`語句的後面。在這種情況下，返回值是通過計算表達式`s.length()*2`而產生的。
可按自己的願望返回任意類型，但倘若不想返回任何東西，就可指示方法返回`void`（空）。下面列出一些例子。

```
boolean flag() { return true; }
float naturalLogBase() { return 2.718; }
void nothing() { return; }
void nothing2() {}
```

若返回類型為`void`，則`return`關鍵字唯一的作用就是退出方法。所以一旦抵達方法末尾，該關鍵字便不需要了。可在任何地方從一個方法返回。但假設已指定了一種非`void`的返回類型，那麼無論從何地返回，編譯器都會確保我們返回的是正確的類型。

到此為止，大家或許已得到了這樣的一個印象：一個程序只是一系列對象的集合，它們的方法將其他對象作為自己的參數使用，而且將消息發給那些對象。這種說法大體正確，但通過以後的學習，大家還會知道如何在一個方法裡作出決策，做一些更細緻的基層工作。至於這一章，只需理解消息傳送就足夠了。


# 2.6 构建Java程序


正式构建自己的第一个Java程序前，还有几个问题需要注意。

## 2.6.1 名字的可见性

在所有程序设计语言里，一个不可避免的问题是对名字或名称的控制。假设您在程序的某个模块里使用了一个名字，而另一名程序员在另一个模块里使用了相同的名字。此时，如何区分两个名字，并防止两个名字互相冲突呢？这个问题在C语言里特别突出。因为程序未提供很好的名字管理方法。C++的类（即Java类的基础）嵌套使用类里的函数，使其不至于同其他类里的嵌套函数名冲突。然而，C++仍然允许使用全局数据以及全局函数，所以仍然难以避免冲突。为解决这个问题，C++用额外的关键字引入了“命名空间”的概念。

由于采用全新的机制，所以Java能完全避免这些问题。为了给一个库生成明确的名字，采用了与Internet域名类似的名字。事实上，Java的设计者鼓励程序员反转使用自己的Internet域名，因为它们肯定是独一无二的。由于我的域名是`BruceEckel.com`，所以我的实用工具库就可命名为`com.bruceeckel.utility.foibles`。反转了域名后，可将点号想象成子目录。

在Java 1.0和Java 1.1中，域扩展名`com`，`edu`，`org`，`net`等都约定为大写形式。所以库的样子就变成：`COM.bruceeckel.utility.foibles`。然而，在Java 1.2的开发过程中，设计者发现这样做会造成一些问题。所以目前的整个软件包都以小写字母为标准。

Java的这种特殊机制意味着所有文件都自动存在于自己的命名空间里。而且一个文件里的每个类都自动获得一个独一无二的标识符（当然，一个文件里的类名必须是唯一的）。所以不必学习特殊的语言知识来解决这个问题——语言本身已帮我们照顾到这一点。

## 2.6.2 使用其他组件

一旦要在自己的程序里使用一个预先定义好的类，编译器就必须知道如何找到它。当然，这个类可能就在发出调用的那个相同的源码文件里。如果是那种情况，只需简单地使用这个类即可——即使它直到文件的后面仍未得到定义。Java消除了“向前引用”的问题，所以不要关心这些事情。

但假若那个类位于其他文件里呢？您或许认为编译器应该足够“联盟”，可以自行发现它。但实情并非如此。假设我们想使用一个具有特定名称的类，但那个类的定义位于多个文件里。或者更糟，假设我们准备写一个程序，但在创建它的时候，却向自己的库加入了一个新类，它与现有某个类的名字发生了冲突。

为解决这个问题，必须消除所有潜在的、纠缠不清的情况。为达到这个目的，要用`import`关键字准确告诉Java编译器我们希望的类是什么。`import`的作用是指示编译器导入一个“包”——或者说一个“类库”（在其他语言里，可将“库”想象成一系列函数、数据以及类的集合。但请记住，Java的所有代码都必须写入一个类中）。

大多数时候，我们直接采用来自标准Java库的组件（部件）即可，它们是与编译器配套提供的。使用这些组件时，没有必要关心冗长的保留域名；举个例子来说，只需象下面这样写一行代码即可：

```
import java.util.Vector;
```

它的作用是告诉编译器我们想使用Java的`Vector`类。然而，`util`包含了数量众多的类，我们有时希望使用其中的几个，同时不想全部明确地声明它们。为达到这个目的，可使用`*`通配符。如下所示：

```
import java.util.*;
```

需导入一系列类时，采用的通常是这个办法。应尽量避免一个一个地导入类。

## 2.6.3 `static`关键字

通常，我们创建类时会指出那个类的对象的外观与行为。除非用`new`创建那个类的一个对象，否则实际上并未得到任何东西。只有执行了`new`后，才会正式生成数据存储空间，并可使用相应的方法。

但在两种特殊的情形下，上述方法并不堪用。一种情形是只想用一个存储区域来保存一个特定的数据——无论要创建多少个对象，甚至根本不创建对象。另一种情形是我们需要一个特殊的方法，它没有与这个类的任何对象关联。也就是说，即使没有创建对象，也需要一个能调用的方法。为满足这两方面的要求，可使用`static`（静态）关键字。一旦将什么东西设为`static`，数据或方法就不会同那个类的任何对象实例联系到一起。所以尽管从未创建那个类的一个对象，仍能调用一个`static`方法，或访问一些`static`数据。而在这之前，对于非`static`数据和方法，我们必须创建一个对象，并用那个对象访问数据或方法。这是由于非`static`数据和方法必须知道它们操作的具体对象。当然，在正式使用前，由于`static`方法不需要创建任何对象，所以它们不可简单地调用其他那些成员，同时不引用一个已命名的对象，从而直接访问非`static`成员或方法（因为非`static`成员和方法必须同一个特定的对象关联到一起）。

有些面向对象的语言使用了“类数据”和“类方法”这两个术语。它们意味着数据和方法只是为作为一个整体的类而存在的，并不是为那个类的任何特定对象。有时，您会在其他一些Java书刊里发现这样的称呼。

为了将数据成员或方法设为`static`，只需在定义前置和这个关键字即可。例如，下述代码能生成一个`static`数据成员，并对其初始化：

```
class StaticTest {
Static int i = 47;
}
```

现在，尽管我们制作了两个`StaticTest`对象，但它们仍然只占据`StaticTest.i`的一个存储空间。这两个对象都共享同样的`i`。请考察下述代码：

```
StaticTest st1 = new StaticTest();
StaticTest st2 = new StaticTest();
```

此时，无论`st1.i`还是`st2.i`都有同样的值47，因为它们引用的是同样的内存区域。

有两个办法可引用一个`static`变量。正如上面展示的那样，可通过一个对象命名它，如`st2.i`。亦可直接用它的类名引用，而这在非静态成员里是行不通的（最好用这个办法引用`static`变量，因为它强调了那个变量的“静态”本质）。

```
StaticTest.i++;
```

其中，`++`运算符会使变量自增。此时，无论`st1.i`还是`st2.i`的值都是48。

类似的逻辑也适用于静态方法。既可象对其他任何方法那样通过一个对象引用静态方法，亦可用特殊的语法格式`类名.方法()`加以引用。静态方法的定义是类似的：

```
class StaticFun {
static void incr() { StaticTest.i++; }
}
```

从中可看出，`StaticFun`的方法`incr()`使静态数据`i`自增。通过对象，可用典型的方法调用`incr()`：

```
StaticFun sf = new StaticFun();
sf.incr();
```

或者，由于`incr()`是一种静态方法，所以可通过它的类直接调用：

```
StaticFun.incr();
```

尽管是“静态”的，但只要应用于一个数据成员，就会明确改变数据的创建方式（一个类一个成员，以及每个对象一个非静态成员）。若应用于一个方法，就没有那么戏剧化了。对方法来说，`static`一项重要的用途就是帮助我们在不必创建对象的前提下调用那个方法。正如以后会看到的那样，这一点是至关重要的——特别是在定义程序运行入口方法`main()`的时候。

和其他任何方法一样，`static`方法也能创建自己类型的命名对象。所以经常把`static`方法作为一个“领头羊”使用，用它生成一系列自己类型的“实例”。


# 2.7 我们的第一个Java程序


最后，让我们正式编一个程序（注释⑤）。它能打印出与当前运行的系统有关的资料，并利用了来自Java标准库的`System`对象的多种方法。注意这里引入了一种额外的注释样式：`//`。它表示到本行结束前的所有内容都是注释：

```
// Property.java
import java.util.*;

public class Property {
  public static void main(String[] args) {
    System.out.println(new Date());
    Properties p = System.getProperties();
    p.list(System.out);
    System.out.println("--- Memory Usage:");
    Runtime rt = Runtime.getRuntime();
    System.out.println("Total Memory = "
                       + rt.totalMemory()
                       + " Free Memory = "
                       + rt.freeMemory());
  }
}
```

⑤：在某些编程环境里，程序会在屏幕上一切而过，甚至没机会看到结果。可将下面这段代码置于`main()`的末尾，用它暂停输出：

```
try {
Thread.currentThread().sleep(5 * 1000);
} catch(InterruptedException e) {}
}
```

它的作用是暂停输出5秒钟。这段代码涉及的一些概念要到本书后面才会讲到。所以目前不必深究，只知道它是让程序暂停的一个技巧便可。


在每个程序文件的开头，都必须放置一个`import`语句，导入那个文件的代码里要用到的所有额外的类。注意我们说它们是“额外”的，因为一个特殊的类库会自动导入每个Java文件：`java.lang`。启动您的Web浏览器，查看由Sun提供的用户文档（如果尚未从 `http://www.java.sun.com` 下载，或用其他方式安装了Java文档，请立即下载）。在`packages.html`文件里，可找到Java配套提供的所有类库名称。请选择其中的`java.lang`。在“Class Index”下面，可找到属于那个库的全部类的列表。由于`java.lang`默认进入每个Java代码文件，所以这些类在任何时候都可直接使用。在这个列表里，可发现`System`和`Runtime`，我们在`Property.java`里用到了它们。`java.lang`里没有列出`Date`类，所以必须导入另一个类库才能使用它。如果不清楚一个特定的类在哪个类库里，或者想检视所有的类，可在Java用户文档里选择“Class Hierarchy”（类分级结构）。在Web浏览器中，虽然要花不短的时间来建立这个结构，但可清楚找到与Java配套提供的每一个类。随后，可用浏览器的“查找”（Find）功能搜索关键字`Date`。经这样处理后，可发现我们的搜索目标以`java.util.Date`的形式列出。我们终于知道它位于`util`库里，所以必须导入 `java.util.*`；否则便不能使用`Date`。

观察`packages.html`文档最开头的部分（我已将其设为自己的默认起始页），请选择`java.lang`，再选`System`。这时可看到`System`类有几个字段。若选择`out`，就可知道它是一个`static PrintStream`对象。由于它是“静态”的，所以不需要我们创建任何东西。`out`对象肯定是3，所以只需直接用它即可。我们能对这个`out`对象做的事情由它的类型决定：`PrintStream`。`PrintStream`在说明文字中以一个超链接的形式列出，这一点做得非常方便。所以假若单击那个链接，就可看到能够为`PrintStream`调用的所有方法。方法的数量不少，本书后面会详细介绍。就目前来说，我们感兴趣的只有`println()`。它的意思是“把我给你的东西打印到控制台，并用一个新行结束”。所以在任何Java程序中，一旦要把某些内容打印到控制台，就可条件反射地写上`System.out.println("内容")`。

类名与文件是一样的。若象现在这样创建一个独立的程序，文件中的一个类必须与文件同名（如果没这样做，编译器会及时作出反应）。类里必须包含一个名为`main()`的方法，形式如下：

```
public static void main(String[] args) {
```

其中，关键字`public`意味着方法可由外部世界调用（第5章会详细解释）。`main()`的参数是包含了`String`对象的一个数组。`args`不会在本程序中用到，但需要在这个地方列出，因为它们保存了在命令行调用的参数。
程序的第一行非常有趣：

```
System.out.println(new Date());
```

请观察它的参数：创建`Date`对象唯一的目的就是将它的值发送给`println()`。一旦这个语句执行完毕，`Date`就不再需要。随之而来的“垃圾收集器”会发现这一情况，并在任何可能的时候将其回收。事实上，我们没太大的必要关心“清除”的细节。

第二行调用了`System.getProperties()`。若用Web浏览器查看联机用户文档，就可知道`getProperties()`是`System`类的一个`static`方法。由于它是“静态”的，所以不必创建任何对象便可调用该方法。无论是否存在该类的一个对象，`static`方法随时都可使用。调用`getProperties()`时，它会将系统属性作为`Properties`类的一个对象生成（注意`Properties`是“属性”的意思）。随后的的引用保存在一个名为`p`的`Properties`引用里。在第三行，大家可看到`Properties`对象有一个名为`list()`的方法，它将自己的全部内容都发给一个我们作为参数传递的`PrintStream`对象。

`main()` 的第四和第六行是典型的打印语句。注意为了打印多个`String`值，用加号（`+`）分隔它们即可。然而，也要在这里注意一些奇怪的事情。在`String`对象中使用时，加号并不代表真正的“相加”。处理字符串时，我们通常不必考虑`+`的任何特殊含义。但是，Java的`String`类要受一种名为“运算符重载”的机制的制约。也就是说，只有在随同`String`对象使用时，加号才会产生与其他任何地方不同的表现。对于字符串，它的意思是“连接这两个字符串”。

但事情到此并未结束。请观察下述语句：

```
System.out.println("Total Memory = "
+ rt.totalMemory()
+ " Free Memory = "
+ rt.freeMemory());
```

其中，`totalMemory()`和`freeMemory()`返回的是数值，并非`String`对象。如果将一个数值“加”到一个字符串身上，会发生什么情况呢？同我们一样，编译器也会意识到这个问题，并魔术般地调用一个方法，将那个数值（`int`，`float`等等）转换成字符串。经这样处理后，它们当然能利用加号“加”到一起。这种“自动类型转换”亦划入“运算符重载”处理的范畴。

许多Java著作都在热烈地辩论“运算符重载”（C++的一项特性）是否有用。目前就是反对它的一个好例子！然而，这最多只能算编译器（程序）的问题，而且只是对`String`对象而言。对于自己编写的任何源代码，都不可能使运算符“重载”。

通过为`Runtime`类调用`getRuntime()`方法，`main()`的第五行创建了一个`Runtime`对象。返回的则是指向一个`Runtime`对象的引用。而且，我们不必关心它是一个静态对象，还是由`new`命令创建的一个对象。这是由于我们不必为清除工作负责，可以大模大样地使用对象。正如显示的那样，`Runtime`可告诉我们与内存使用有关的信息。


# 2.8 注释和嵌入文档


(2)8 注释和嵌入文档

Java里有两种类型的注释。第一种是传统的、C语言风格的注释，是从C++继承而来的。这些注释用一个 `/*` 起头，随后是注释内容，并可跨越多行，最后用一个`*/`结束。注意许多程序员在连续注释内容的每一行都用一个 `*` 开头，所以经常能看到象下面这样的内容：

```
/* 这是
* 一段注释，
* 它跨越了多个行
*/
```

但请记住，进行编译时，`/*`和`*/`之间的所有东西都会被忽略，所以上述注释与下面这段注释并没有什么不同：

```
/* 这是一段注释，
它跨越了多个行 */
```

第二种类型的注释也起源于C++。这种注释叫作“单行注释”，以一个 `//` 起头，表示这一行的所有内容都是注释。这种类型的注释更常用，因为它书写时更方便。没有必要在键盘上寻找 `/` ，再寻找 `*` （只需按同样的键两次），而且不必在注释结尾时加一个结束标记。下面便是这类注释的一个例子：

```
// 这是一条单行注释
```

## 2.8.1 注释文档

对于Java语言，最体贴的一项设计就是它并没有打算让人们为了写程序而写程序——人们也需要考虑程序的文档化问题。对于程序的文档化，最大的问题莫过于对文档的维护。若文档与代码分离，那么每次改变代码后都要改变文档，这无疑会变成相当麻烦的一件事情。解决的方法看起来似乎很简单：将代码同文档“链接”起来。为达到这个目的，最简单的方法是将所有内容都置于同一个文件。然而，为使一切都整齐划一，还必须使用一种特殊的注释语法，以便标记出特殊的文档；另外还需要一个工具，用于提取这些注释，并按有价值的形式将其展现出来。这些都是Java必须做到的。

用于提取注释的工具叫作`javadoc`。它采用了部分来自Java编译器的技术，查找我们置入程序的特殊注释标记。它不仅提取由这些标记指示的信息，也将毗邻注释的类名或方法名提取出来。这样一来，我们就可用最轻的工作量，生成十分专业的程序文档。

`javadoc`输出的是一个HTML文件，可用自己的Web浏览器查看。该工具允许我们创建和管理单个源文件，并生动生成有用的文档。由于有了`javadoc`，所以我们能够用标准的方法创建文档。而且由于它非常方便，所以我们能轻松获得所有Java库的文档。

## 2.8.2 具体语法

所有javadoc命令都只能出现于 `/**` 注释中。但和平常一样，注释结束于一个 `*/` 。主要通过两种方式来使用`javadoc`：嵌入的HTML，或使用“文档标记”。其中，“文档标记”（Doc tags）是一些以`@`开头的命令，置于注释行的起始处（但前导的`*`会被忽略）。

有三种类型的注释文档，它们对应于位于注释后面的元素：类、变量或者方法。也就是说，一个类注释正好位于一个类定义之前；变量注释正好位于变量定义之前；而一个方法定义正好位于一个方法定义的前面。如下面这个简单的例子所示：

```
/** 一个类注释 */
public class docTest {
/** 一个变量注释 */
public int i;
/** 一个方法注释 */
public void f() {}
}
```

注意`javadoc`只能为`public`（公共）和`protected`（受保护）成员处理注释文档。`private`（私有）和“友好”（详见5章）成员的注释会被忽略，我们看不到任何输出（也可以用`-private`标记包括`private`成员）。这样做是有道理的，因为只有`public`和`protected`成员才可在文件之外使用，这是客户程序员的希望。然而，所有类注释都会包含到输出结果里。

上述代码的输出是一个HTML文件，它与其他Java文档具有相同的标准格式。因此，用户会非常熟悉这种格式，可在您设计的类中方便地“漫游”。设计程序时，请务必考虑输入上述代码，用`javadoc`处理一下，观看最终HTML文件的效果如何。

## 2.8.3 嵌入HTML

`javadoc`将HTML命令传递给最终生成的HTML文档。这便使我们能够充分利用HTML的巨大威力。当然，我们的最终动机是格式化代码，不是为了哗众取宠。下面列出一个例子：

```
/**
* <pre>
* System.out.println(new Date());
* </pre>
*/
```

亦可象在其他Web文档里那样运用HTML，对普通文本进行格式化，使其更具条理、更加美观：

```
/**
* 您<em>甚至</em>可以插入一个列表：
* <ol>
* <li> 项目一
* <li> 项目二
* <li> 项目三
* </ol>
*/
```

注意在文档注释中，位于一行最开头的星号会被`javadoc`丢弃。同时丢弃的还有前导空格。`javadoc` 会对所有内容进行格式化，使其与标准的文档外观相符。不要将`<h1>`或`<hr>`这样的标题当作嵌入HTML使用，因为`javadoc`会插入自己的标题，我们给出的标题会与之冲撞。

所有类型的注释文档——类、变量和方法——都支持嵌入HTML。

## 2.8.4 `@see`：引用其他类

所有三种类型的注释文档都可包含`@see`标记，它允许我们引用其他类里的文档。对于这个标记，`javadoc`会生成相应的HTML，将其直接链接到其他文档。格式如下：

```
@see 类名
@see 完整类名
@see 完整类名#方法名
```

每一格式都会在生成的文档里自动加入一个超链接的“See Also”（参见）条目。注意`javadoc`不会检查我们指定的超链接，不会验证它们是否有效。

## 2.8.5 类文档标记

随同嵌入HTML和`@se`e引用，类文档还可以包括用于版本信息以及作者姓名的标记。类文档亦可用于“接口”目的（本书后面会详细解释）。


**1. `@version`**


格式如下：

```
@version 版本信息
```

其中，“版本信息”代表任何适合作为版本说明的资料。若在`javadoc`命令行使用了`-version`标记，就会从生成的HTML文档里提取出版本信息。

**2. `@author`**

格式如下：

```
@author 作者信息
```

其中，“作者信息”包括您的姓名、电子函件地址或者其他任何适宜的资料。若在`javadoc`命令行使用了`-author`标记，就会专门从生成的HTML文档里提取出作者信息。

可为一系列作者使用多个这样的标记，但它们必须连续放置。全部作者信息会一起存入最终HTML代码的单独一个段落里。

## 2.8.6 变量文档标记

变量文档只能包括嵌入的HTML以及`@see`引用。

## 2.8.7 方法文档标记

除嵌入HTML和`@see`引用之外，方法还允许使用针对参数、返回值以及异常的文档标记。

**1. `@param`**
格式如下：

```
@param 参数名 说明
```

其中，“参数名”是指参数列表内的标识符，而“说明”代表一些可延续到后续行内的说明文字。一旦遇到一个新文档标记，就认为前一个说明结束。可使用任意数量的说明，每个参数一个。

**2. `@return`**

格式如下：

```
@return 说明
```

其中，“说明”是指返回值的含义。它可延续到后面的行内。

**3. `@exception`**

有关“异常”（`Exception`）的详细情况，我们会在第9章讲述。简言之，它们是一些特殊的对象，若某个方法失败，就可将它们“扔出”对象。调用一个方法时，尽管只有一个异常对象出现，但一些特殊的方法也许能产生任意数量的、不同类型的异常。所有这些异常都需要说明。所以，异常标记的格式如下：

```
@exception 完整类名 说明
```

其中，“完整类名”明确指定了一个异常类的名字，它是在其他某个地方定义好的。而“说明”（同样可以延续到下面的行）告诉我们为什么这种特殊类型的异常会在方法调用中出现。

**4. `@deprecated`**

这是Java 1.1的新特性。该标记用于指出一些旧功能已由改进过的新功能取代。该标记的作用是建议用户不必再使用一种特定的功能，因为未来改版时可能摒弃这一功能。若将一个方法标记为`@deprecated`，则使用该方法时会收到编译器的警告。

## 2.8.8 文档示例

下面还是我们的第一个Java程序，只不过已加入了完整的文档注释：

92页程序

第一行：

```
//: Property.java
```

采用了我自己的方法：将一个`:`作为特殊的记号，指出这是包含了源文件名字的一个注释行。最后一行也用这样的一条注释结尾，它标志着源代码清单的结束。这样一来，可将代码从本书的正文中方便地提取出来，并用一个编译器检查。这方面的细节在第17章讲述。


# 2.9 编码样式


一个非正式的Java编程标准是大写一个类名的首字母。若类名由几个单词构成，那么把它们紧靠到一起（也就是说，不要用下划线来分隔名字）。此外，每个嵌入单词的首字母都采用大写形式。例如：

```
class AllTheColorsOfTheRainbow { // ...}
```

对于其他几乎所有内容：方法、字段（成员变量）以及对象引用名称，可接受的样式与类样式差不多，只是标识符的第一个字母采用小写。例如：

```
class AllTheColorsOfTheRainbow {
int anIntegerRepresentingColors;
void changeTheHueOfTheColor(int newHue) {
// ...
}
// ...
}
```

当然，要注意用户也必须键入所有这些长名字，而且不能输错。


# 2.10 總結


通過本章的學習，大家已接觸了足夠多的Java編程知識，已知道如何自行編寫一個簡單的程序。此外，對語言的總體情況以及一些基本思想也有了一定程度的認識。然而，本章所有例子的模式都是單線形式的“這樣做，再那樣做，然後再做另一些事情”。如果想讓程序作出一項選擇，又該如何設計呢？例如，“假如這樣做的結果是紅色，就那樣做；如果不是，就做另一些事情”。對於這種基本的編程方法，下一章會詳細說明在Java裡是如何實現的。

# 2.11 練習


(1) 參照本章的第一個例子，創建一個“Hello，World”程序，在屏幕上簡單地顯示這句話。注意在自己的類裡只需一個方法（`main`方法會在程序啟動時執行）。記住要把它設為`static`形式，並置入參數列表——即使根本不會用到這個列表。用`javac`編譯這個程序，再用`java`運行它。

(2) 寫一個程序，打印出從命令行獲取的三個參數。

(3) 找出`Property.java`第二個版本的代碼，這是一個簡單的註釋文檔示例。請對文件執行`javadoc`，並在自己的Web瀏覽器裡觀看結果。

(4) 以練習(1)的程序為基礎，向其中加入註釋文檔。利用`javadoc`，將這個註釋文檔提取為一個HTML文件，並用Web瀏覽器觀看。
