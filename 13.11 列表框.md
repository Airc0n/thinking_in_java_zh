# 13.11 列表框

列表框與選擇框有完全的不同，而不僅僅是當我們在激活選擇框時的顯示不同，列表框固定在屏幕的指定位置不會改變。另外，一個列表框允許多個選擇：如果我們單擊在超過一個的項目上，未選擇的則表現為高亮度，我們可以選擇象我們想要的一樣的多。如果我們想察看項目列表，我們可以調用`getSelectedItem()`來產生一個被選擇的項目列表。要想從一個組裡刪除一個項目，我們必須再一次的單擊它。列表框，當然這裡有一個問題就是它默認的動作是雙擊而不是單擊。單擊從組中增加或刪除項目，雙擊調用`action()`。解決這個問題的方法是象下面的程序假設的一樣重新培訓我們的用戶。

```
//: List1.java
// Using lists with action()
import java.awt.*;
import java.applet.*;

public class List1 extends Applet {
  String[] flavors = { "Chocolate", "Strawberry",
    "Vanilla Fudge Swirl", "Mint Chip",
    "Mocha Almond Fudge", "Rum Raisin",
    "Praline Cream", "Mud Pie" };
  // Show 6 items, allow multiple selection:
  List lst = new List(6, true);
  TextArea t = new TextArea(flavors.length, 30);
  Button b = new Button("test");
  int count = 0;
  public void init() {
    t.setEditable(false);
    for(int i = 0; i < 4; i++)
      lst.addItem(flavors[count++]);
    add(t);
    add(lst);
    add(b);
  }
  public boolean action (Event evt, Object arg) {
    if(evt.target.equals(lst)) {
      t.setText("");
      String[] items = lst.getSelectedItems();
      for(int i = 0; i < items.length; i++)
        t.appendText(items[i] + "\n");
    }
    else if(evt.target.equals(b)) {
      if(count < flavors.length)
        lst.addItem(flavors[count++], 0);
    }
    else
      return super.action(evt, arg);
    return true;
  }
} ///:~
```

按下按鈕時，按鈕增加項目到列表的頂部（因為`addItem()`的第二個參數為零）。增加項目到列表框比到選擇框更加的合理，因為用戶期望去滾動一個列表框（因為這個原因，它有內建的滾動條）但用戶並不願意像在前面的例子裡不得不去計算怎樣才能滾動到要要的那個項目。
然而，調用`action()`的唯一方法就是通過雙擊。如果我們想監視用戶在我們的列表中的所作所為（尤其是單擊），我們必須提供一個可供選擇的方法。

## 13.11.1 handleEvent()

到目前為止，我們已使用了`action()`，現有另一種方法`handleEvent()`可對每一事件進行嘗試。當一個事件發生時，它總是針對單獨事件或發生在單獨的事件對象上。該對象的`handleEvent()`方法是自動調用的，並且是被`handleEvent()`創建並傳遞到`handleEvent()`裡。默認的`handleEvent()`（`handleEvent()`定義在組件裡，基類的所有控件都在AWT裡）將像我們以前一樣調用`action()`或其它同樣的方法去指明鼠標的活動、鍵盤活動或者指明移動的焦點。我們將會在本章的後面部分看到。

如果其它的方法－特別是`action()`－不能滿足我們的需要怎麼辦呢？至於列表框，例如，如果我想捕捉鼠標單擊，但`action()`只響應雙擊怎麼辦呢？這個解答是重載`handleEvent()`，畢竟它是從程序片中得到的，因此可以重載任何非確定的方法。當我們為程序片重載`handleEvent()`時，我們會得到所有的事件在它們發送出去之前，所以我們不能假設“這裡有我的按鈕可做的事件，所以我們可以假設按鈕被按下了”從它被`action()`設為真值。在`handleEvent()`中按鈕擁有焦點且某人對它進行分配都是可能的。不論它合理與否，我們可測試這些事件並遵照`handleEvent()`來進行操作。

為了修改列表樣本，使它會響應鼠標的單擊，在`action()`中按鈕測試將被重載，但代碼會處理的列表將像下面的例子被移進`handleEvent()`中去：

```
//: List2.java
// Using lists with handleEvent()
import java.awt.*;
import java.applet.*;

public class List2 extends Applet {
  String[] flavors = { "Chocolate", "Strawberry",
    "Vanilla Fudge Swirl", "Mint Chip",
    "Mocha Almond Fudge", "Rum Raisin",
    "Praline Cream", "Mud Pie" };
  // Show 6 items, allow multiple selection:
  List lst = new List(6, true);
  TextArea t = new TextArea(flavors.length, 30);
  Button b = new Button("test");
  int count = 0;
  public void init() {
    t.setEditable(false);
    for(int i = 0; i < 4; i++)
      lst.addItem(flavors[count++]);
    add(t);
    add(lst);
    add(b);
  }
  public boolean handleEvent(Event evt) {
    if(evt.id == Event.LIST_SELECT ||
       evt.id == Event.LIST_DESELECT) {
      if(evt.target.equals(lst)) {
        t.setText("");
        String[] items = lst.getSelectedItems();
        for(int i = 0; i < items.length; i++)
          t.appendText(items[i] + "\n");
      }
      else
        return super.handleEvent(evt);
    }
    else
      return super.handleEvent(evt);
    return true;
  }
  public boolean action(Event evt, Object arg) {
    if(evt.target.equals(b)) {
      if(count < flavors.length)
        lst.addItem(flavors[count++], 0);
    }
    else
      return super.action(evt, arg);
    return true;
  }
} ///:~
```

這個例子同前面的例子相同除了增加了`handleEvent()`外簡直一模一樣。在程序中做了試驗來驗證是否列表框的選擇和非選擇存在。現在請記住，`handleEvent()`被程序片所重載，所以它能在窗體中任何存在，並且被其它的列表當成事件來處理。因此我們同樣必須通過試驗來觀察目標。（雖然在這個例子中，程序片中只有一個列表框所以我們能假設所有的列表框事件必須服務於列表框。這是一個不好的習慣，一旦其它的列表框加入，它就會變成程序中的一個缺陷。）如果列表框匹配一個我們感興趣的列表框，像前面的一樣的代碼將按上面的策略來運行。注意`handleEvent()`的窗體與`action()`的相同：如果我們處理一個單獨的事件，將返回真值，但如果我們對其它的一些事件不感興趣，通過`handleEvent()`我們必須返回`super.handleEvent()`值。這便是程序的核心，如果我們不那樣做，其它的任何一個事件處理代碼也不會被調用。例如，試註解在上面的代碼中返回`super.handleEvent(evt)`的值。我們將發現`action()`沒有被調用，當然那不是我們想得到的。對`action()`和`handlEvent()`而言，最重要的是跟著上面例子中的格式，並且當我們自己不處理事件時一直返回基類的方法版本信息。（在例子中我們將返回真值）。（幸運的是，這些類型的錯誤的僅屬於Java 1.0版，在本章後面將看到的新設計的Java 1.1消除了這些類型的錯誤。）

在windows裡，如果我們按下`shift`鍵，列表框自動允許我們做多個選擇。這非常的棒，因為它允許用戶做單個或多個的選擇而不是編程期間固定的。我們可能會認為我們變得更加的精明，並且當一個鼠標單擊被`evt.shiftdown()`產生時如果`shift`鍵是按下的將執行我們自己的試驗程序。AWT的設計妨礙了我們－我們不得不去了解哪個項目被鼠標點擊時是否按下了`shift`鍵，所以我們能取消其餘部分所有的選擇並且只選擇那一個。不管怎樣，我們是不可能在Java 1.0版中做出來的。（Java 1.1將所有的鼠標、鍵盤、焦點事件傳送到列表中，所以我們能夠完成它。）
